'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/course/service-interface/','title':"NODE对接(SI接口说明)",'content':"Service Interface (SI) 接口说明\r#\r\r Zro上开放了SI服务，使得第三方可以通过rpc/web3连接Zro，获得无状态的公链服务。\nSI的使用方式是不维护第三方创建的公私钥，因此，第三方需要自己创建存储公私钥，并在需要的时候提供给SI。\nCreateKr\r#\r\r 创建公私钥对\n Request   {\u0026quot;id\u0026quot;:0,\u0026quot;jsonrpc\u0026quot;:\u0026quot;2.0\u0026quot;,\u0026quot;method\u0026quot;:\u0026quot;ssi_createKr\u0026quot;,\u0026quot;params\u0026quot;:null}\r Successful Response   {\r\u0026quot;SKr\u0026quot;:\u0026quot;0x5bf7d....a0016\u0026quot;, //私钥\r\u0026quot;PKr\u0026quot;:\u0026quot;0x904bb....09baa\u0026quot; //公钥\r}\r szkCreateKr 生成 SuperZK2.0 协议账户  GetBlocksInfo\r#\r\r 用来主动同步区块数据\n Request   {\r\u0026quot;id\u0026quot;:0,\r\u0026quot;jsonrpc\u0026quot;:\u0026quot;2.0\u0026quot;,\r\u0026quot;method\u0026quot;:\u0026quot;ssi_getBlocksInfo\u0026quot;,\r\u0026quot;params\u0026quot;:[\r\u0026quot;0x0\u0026quot;, //起始块\r\u0026quot;0x5\u0026quot; //最多获取多少个块\r]\r}\r Successful Response   [\r{\r\u0026quot;Num\u0026quot;:\u0026quot;0x0\u0026quot;, //块号\r\u0026quot;Hash\u0026quot;:\u0026quot;0x2472...2003\u0026quot; //Block Hash\r\u0026quot;Outs\u0026quot;:[\r{\r\u0026quot;Hash\u0026quot;:\u0026quot;0x...\u0026quot; //Tx Hash\r\u0026quot;Root\u0026quot;:\u0026quot;0xfa2e8....5a717\u0026quot;, //该Out的Merkle Root\r\u0026quot;PKr\u0026quot;: \u0026quot;0xaf630....7ca29\u0026quot; //该Out的暂存公钥\r}\r],\r\u0026quot;Nils\u0026quot;:[\u0026quot;0x...\u0026quot;,...] //作废码\r},\r...\r]\rDetail\r#\r\r 获取对应Out的明文信息\n Request   {\r\u0026quot;id\u0026quot;:1,\r\u0026quot;jsonrpc\u0026quot;:\u0026quot;2.0\u0026quot;,\r\u0026quot;method\u0026quot;:\u0026quot;ssi_detail\u0026quot;,\r\u0026quot;params\u0026quot;:[\r[\u0026quot;0x...\u0026quot;,\u0026quot;0x...\u0026quot;], //需要解出明文的out的root列表，需要有相同的PKr。\r\u0026quot;0x...\u0026quot; //该Out的PKr对应的SKr\r]\r}\r Successful Response   {\r\u0026quot;id\u0026quot;:1,\r\u0026quot;jsonrpc\u0026quot;:\u0026quot;2.0\u0026quot;,\r\u0026quot;result\u0026quot;:[\r{\r\u0026quot;Asset\u0026quot; :{ //Out的资产\r\u0026quot;Tkn\u0026quot; :{ //Token资产\r\u0026quot;Currency\u0026quot;:\u0026quot;0x...\u0026quot;, //Token的币名\r\u0026quot;Value\u0026quot;:10000000 //Token的金额(bigint)\r},\rTkt:{ //Ticket资产\r\u0026quot;Category\u0026quot;:\u0026quot;0x...\u0026quot;, //Ticket类型\r\u0026quot;Value\u0026quot;:\u0026quot;0x...\u0026quot; //Ticket的值\r}\r},\rMemo:\u0026quot;...\u0026quot;, //本Out的备注\rNil:\u0026quot;0x...\u0026quot; //本Out的作废码\r},\r...\r]\r}\rGenTx\r#\r\r 创建交易，需要发送方自己配平Out和In，注意In和Out的个数越多，交易生成的时间越长。\n Request   {\r\u0026quot;id\u0026quot;:1,\r\u0026quot;jsonrpc\u0026quot;:\u0026quot;2.0\u0026quot;,\r\u0026quot;method\u0026quot;:\u0026quot;ssi_genTx\u0026quot;,\r\u0026quot;params\u0026quot;:[{\rGas: 10000, //本次交易的GasLimit\rGasPrice: 1000000000, //本次交易的GasPrice\rFrom: { //代表发送者的Kr\rSKr:\u0026quot;0x...\u0026quot;,\rPKr:\u0026quot;0x...\u0026quot;\r}, Ins: [\r{\rSKr: \u0026quot;0x...\u0026quot;, //输入的UTXO对应的SKr\rRoot: \u0026quot;0x...\u0026quot; //输入的UTXO对应的Root\r},\r...\r],\rOuts: [\r{\rPKr: \u0026quot;0x...\u0026quot;, //输出的PKr\rAsset: {...}, //输出的资产，参考Detail\rMemo: \u0026quot;0x.....\u0026quot; //本次输出的备注\r},\r...\r]\r}]\r}\r Successful Response   {\r\u0026quot;id\u0026quot;:1,\r\u0026quot;jsonrpc\u0026quot;:\u0026quot;2.0\u0026quot;,\r\u0026quot;result\u0026quot;:\u0026quot;0x...\u0026quot; //该交易的hash\r}\r注意 * Zro会根据当前机器的性能决定并行计算的数量，交易生成时间与引用的UTXO的数量成正比。 * 一个解决方案是对充值的UTXO进行merge，另外一个是延长接口调用的超时时间。 * \u0026ndash;rpcwritetimeout [SECOND] 启动Zro的时候加上这个参数，可以设置Zro回写的超时时间，单位是秒。\nCommitTx\r#\r\r 提交已经创建的交易\n Request   {\r\u0026quot;id\u0026quot;:1,\r\u0026quot;jsonrpc\u0026quot;:\u0026quot;2.0\u0026quot;,\r\u0026quot;method\u0026quot;:\u0026quot;ssi_commitTx\u0026quot;,\r\u0026quot;params\u0026quot;:[\r\u0026quot;0x...\u0026quot; //之前genTx创建的交易的hash\r]\r}\r Successful Response   {\r\u0026quot;id\u0026quot;:1,\r\u0026quot;jsonrpc\u0026quot;:\u0026quot;2.0\u0026quot;,\r\u0026quot;result\u0026quot;:null\r}\r建议对接方案\r#\r\r  用户创建  为每个用户创建不同的Kr并存储在数据库中   充值：  不断的调用GetBlocksInfo获取最新的区块信息 查找区块的Out中的PKr是否为自己创建，如果是，就调用Detail解出Out的明文信息以及对应的作废码Nil。 查找区块中的Nil是否在Detail的时候解出过，如果找到，说明对应的UTXO已经被用掉了。   提现  获取已经存在的UTXO作为In，并构造出Out，配平后调用GenTx签名生成Tx。 调用CommitTx提交该Tx。    "});index.add({'id':1,'href':'/docs/introduction/build-from-sourcecoude/','title':"源码编译",'content':"从源码编译开始\r#\r\r 本机环境\r#\r\rubuntu16.04 / go1.13.11\n1. 安装依赖库，获取源码\r#\r\r apt-get install -y build-essential apt-get install libboost-all-dev apt-get install libgmp-dev go env -w GO111MODULE=off cd $GOPATH/src/github.com mkdir ZorroChain cd ZorroChain git clone https://github.com/ZorroChain/zorro.git 2. 设置动态库加载路径\r#\r\r  windows  # cmd: set path=%path%;%gopath%\\src\\github.com\\ZorroChain\\zorro\\czk\\czero\\lib_WINDOWS_AMD64 # powershell: $env:path=$env:path+\u0026#34;;\u0026#34;+$env:gopath+\u0026#34;\\src\\github.com\\ZorroChain\\zorro\\czk\\czero\\lib_WINDOWS_AMD64\u0026#34;  mac  export DYLD_LIBRARY_PATH=$GOPATH/src/github.com/ZorroChain/zorro/czk/czero/lib_DARWIN_AMD64  linux  # Linux内核版本v3: export LD_LIBRARY_PATH=$GOPATH/src/github.com/ZorroChain/zorro/czk/czero/lib_LINUX_AMD64_V3 # Linux内核版本v4: export LD_LIBRARY_PATH=$GOPATH/src/github.com/ZorroChain/zorro/czk/czero/lib_LINUX_AMD64_V4 3. 编译\r#\r\r cd zorro go install . ./cmd/... 生成的执行文件位于$GOPATH/bin中\n4. 启动节点\r#\r\r  window  zro.exe --exchange --mineMode --stake --rpc --rpcaddr=\u0026#34;0.0.0.0\u0026#34; --dashboard --vmodule=dashboard=5 --rpcvhosts=\u0026#34;*\u0026#34; --rpccorsdomain=\u0026#34;*\u0026#34; --rpcapi=\u0026#34;exchange,zorro,net,stake\u0026#34; --exchangeValueStr zro.exe attach ipc:\\\\.\\pipe\\zro.ipc  mac  zro --exchange --mineMode --stake --rpc --rpcaddr=\u0026#34;0.0.0.0\u0026#34; --dashboard --vmodule=dashboard=5 --rpcvhosts=\u0026#34;*\u0026#34; --rpccorsdomain=\u0026#34;*\u0026#34; --rpcapi=\u0026#34;exchange,zorro,net,stake\u0026#34; --exchangeValueStr zro attach --exchange  linux  zro --exchange --mineMode --stake --rpc --rpcaddr=\u0026#34;0.0.0.0\u0026#34; --dashboard --vmodule=dashboard=5 --rpcvhosts=\u0026#34;*\u0026#34; --rpccorsdomain=\u0026#34;*\u0026#34; --rpcapi=\u0026#34;exchange,zorro,net,stake\u0026#34; --exchangeValueStr zro attach zro attach启动一个JS虚拟机驱动的交互式控制台，或者也可以在第一个命令后直接加console。\n"});index.add({'id':2,'href':'/docs/introduction/','title':"轻松入门",'content':""});index.add({'id':3,'href':'/docs/course/exchange-interface/','title':"WALLET对接(EI接口说明)",'content':"Exchange Interface (EI) 接口说明\r#\r\r EI 接口的对接方式，exchange服务代管用户的 TK，负责追踪用户的 UTXO ，并提供在线和离线的签名方式。 对比 SI 接口需要对接方自己管理 UTXO，SEI 更加简单、安全、实用。\n请对接用户注意，并认真阅读本文\n  因为Seed-\u0026gt;SK-\u0026gt;TK-\u0026gt;PK是一一对应的，一个PK可以通过随机数对应非常多的PKr。\n  每个用户通过随机数关联到不同的PKr，再关联到一个唯一的PK上，不需要为每个用户生成一个Seed。\n  请经常对账户的UTXO进行Merge，否则转账时过多的UTXO导致签名时间过长，将严重影响用户体验。\n  账户\r#\r\r 账户由 Seed、SK、TK、PK、PKr 四种密钥构成，生成关系于下：\nseed(种子) -\u0026gt; sk(私钥) -\u0026gt; TK(跟踪密钥) -\u0026gt; PK(公钥) -\u0026gt; PKr(收款码)\rseed(种子)\r#\r\r seed 是32长度的BYTE数组，可以由HASH算法或者助记词生成。拥有了 seed 就可以推出后续所有的密钥，因此必须绝对安全保存。  sk(私钥)\r#\r\r 私钥sk一共64个BYTE，由两个32BYTE的大整数组成，并且与 seed 一一对应。  sk=(zsk,vsk) \\;\\;zsk \\in Fr, \\; vsk \\in Fr    私钥用来对交易签名，也需要绝对安全保存。 可以由 seed 生成出来 Go语言  cpt.ZeroInit_OnlyInOuts() //初始化加密库  var seed keys.Uint256 seed=c_type.RandUint256() sk:=superzk.Seed2Sk( \u0026amp;seed, //Seed 32 Byte 的随机数  1 //SuperZK协议版本 1: SuperZK1.0, 2: SuperZK2.0  )  JS语言  const newKeysBySeed = require(\u0026#39;js-zorro-client\u0026#39;).newKeysBySeed let seed = Buffer.alloc( 32, \u0026#39;fd1b401d2bbfa09fba577b398b09b5ea075bd8f37773095c6e62271a4b080977\u0026#39;, \u0026#39;hex\u0026#39; ) let keys = newKeysBySeed( seed, //seed 可以直接用字符串(hex|base58)  1 //SuperZK协议版本 1: SuperZK1.0, 2: SuperZK2.0  ) let sk = keys.sk.toString(\u0026#39;hex\u0026#39;) let tk_hex = keys.tk.toString(\u0026#39;hex\u0026#39;) let tk_base58 = keys.tk.ToBase58() TK(跟踪密钥)\r#\r\r TK 是64长度的BYTE数组，由一个32BYTE的ECC_{fp}上的点和一个大整数构成，ZPK也是PK的前 32 BYTE，vsk是sk的后32 BYTE。TK 与 sk 一一对应。  TK=(ZPK,vsk) \\; ZPK \\in ECC_{fp},\\; vsk \\in Fr   TK 只能用来查看属于账户的UTXO的详情，可以提供给可信第三方进行独立审计。 TK 由 sk 生成 Go语言  tk:=superzk.Sk2Tk(\u0026amp;sk) //SuperZK1.0/2.0 都可以使用  JS语言  const newKeysBySk = require(\u0026#39;js-zorro-client\u0026#39;).newKeysBySk let sk = Buffer.alloc( 64, \u0026#39;4e7f432c24d2......e1513eadfef9d1cd604\u0026#39;, \u0026#39;hex\u0026#39; ) let keys = newKeysBySk(sk) //sk 可以直接用字符串(hex|base58)  let tk_hex = keys.tk.toString(\u0026#39;hex\u0026#39;) let tk_base58 = keys.tk.ToBase58() let pk_hex = keys.pk.toString(\u0026#39;hex\u0026#39;) let pk_base58 = keys.pk.ToBase58() PK(公钥)\r#\r\r 公钥PK也是64 BYTE，由两个 32 BYTE 的 ECC_{fp} 上的点构成 ，与 TK 也是一一对应的。  PK=(ZPK,VPK) \\; ZPK \\in ECC_{fp}, \\; VPK \\in ECC_{fp}   PK 用来生成 PKr (收款码)。可以提供PK给第三方，第三方通过PK生成你的PKr(收款码)再给你转账，而自己使用TK来跟踪入账情况。但因为安全和性能的关系，不建议对接方直接使用。 PK 由 TK 生成。 Go语言  pk:=superzk.Tk2Pk(\u0026amp;tk) // tk: SuperZK1.0/2.0 协议跟踪秘钥  JS语言  const newKeysByTk = require(\u0026#39;js-zorro-client\u0026#39;).newKeysByPK let tk = Buffer.alloc( 64, \u0026#39;6a367411b800be76a9d......1ee1513eadfef9d1cd604\u0026#39;, \u0026#39;hex\u0026#39; ) let keys = newKeysByTk(tk) //tk 可以直接用字符串(hex|base58)  let pk_hex = keys.pk.toString(\u0026#39;hex\u0026#39;) let pk_base58 = keys.pk.ToBase58() PKr(收款码)\r#\r\r 收款码 PKr 是一个 96 BYTE的二进制数据，由三个 32 BYTE 的 ECC_{fp} 上的点构成。可以通过keys.Addr2PKr将PK和一个随机数转换成PKr。  PKr=(ZPKr,VPKr,BASEr) \\; ZPKr \\in ECC_{fp}, \\; VPKr \\in ECC_{fp}, \\; BASEr \\in ECC_{fp}   PKr 是UTXO的目标。每个 PK 对应非常多个PKr。指向这个PKr的UTXO可以由TK解密，在使用的时候由sk签名。 PKr 由 PK 加入一个 32 BYTE 的随机数生成。 Go语言  rnd:=c_superzk.RandomFr() pkr:=superzk.PK2PKr(\u0026amp;pk,\u0026amp;rnd) //SuperZK2.0/1.0 都可以使用  JS语言  const newKeysByPK = require(\u0026#39;js-zorro-client\u0026#39;).newKeysByPK //SuperZK1.0/2.0 共用  const Czero = require(\u0026#39;js-zorro-client\u0026#39;).Czero let pk = Buffer.alloc( 64, \u0026#39;6a367411b800be......df5fb72aba4019\u0026#39;, \u0026#39;hex\u0026#39; ) let rnd = Czero.RandomU32() let keys = newKeysByPK(pk) //pk 可以直接用字符串(hex|base58)  let pkr = keys.GenPKr(rnd) let pkr_hex = pkr.toString(\u0026#34;hex\u0026#34;) let pkr_base58 = pkr.ToBase58() zro 控制台中Base58和Hex编码互转\r#\r\r\u0026gt; web3.addressToHex(zorro.accounts[0]) \u0026#34;0x0dbd9c096......849304201ea6\u0026#34; \u0026gt; web3.hexToBase58(\u0026#34;0x0dbd9c09......9304201ea6\u0026#34;) \u0026#34;GwA94QDTyQ86cE5jcuYCyrQ9Bu9FRcXfq4dxQhryTDzhkahUjYSHcjZ5yFF9bvaZPRMUwR8k5uW4bT3DvPf77a5\u0026#34; 离线签名\r#\r\r 当从全节点程序(zro)，构造了交易之后，需要用zorro的客户端进行离线签名。\n离线签名程序也分为Go版本和JS版本：\nGo语言\r#\r\rimport \u0026#39;github.com/ZorroChain/zorro/zero/txtool/flight\u0026#39; import \u0026#39;github.com/ZorroChain/zorro/zero/txtool\u0026#39; import \u0026#39;github.com/ZorroChain/zorro/czk/cpt\u0026#39; param_str:=\u0026#39;{\u0026#34;Gas\u0026#34;:25000,\u0026#34;GasPrice\u0026#34;:1000000000,\u0026#34;From\u0026#34;:{\u0026#34;SKr\u0026#34;:\u0026#34;0x0 .... }\u0026#39; //由全节点构造 sk_str:=\u0026#39;0xfd1b401d2bbfa09fba577b398b09b5ea075bd8f37773095c6e62271a4b080977\u0026#39; //------初始化----- cpt.ZeroInit_OnlyInOuts() //全局只能执行一次 //------txParam--- var param txtool.GTxParam json.Unmarshal([]byte(param_str),\u0026amp;param) //------私钥---- bs, _ := hexutil.Decode(sk_str) sk := keys.Uint512{} copy(sk[:], bs) //------签名---- gtx, _:=flight.SignTx(sk,param) //------转为JSON----- tx, _ := json.Marshal(\u0026amp;gtx) JS语言\r#\r\rconst account = require(\u0026#39;js-zorro-client\u0026#39;).Account const tx = require(\u0026#39;js-zorro-client\u0026#39;).Tx //------ const seedStr = \u0026#39;fd1b401d2bbfa09fba577b398b09b5ea075bd8f37773095c6e62271a4b080977\u0026#39; const txParamStr = \u0026#39;{\u0026#34;Gas\u0026#34;:25000,\u0026#34;GasPrice\u0026#34;:1000000000,\u0026#34;Fro .... }\u0026#39; //由全节点构造 //------ const seed = Buffer.alloc(32, seedStr, \u0026#39;hex\u0026#39;) const keys = account.NewKeys(seed) const skStr = keys.sk.toString(\u0026#39;hex\u0026#39;) //------ tx.SignTx( txParamStr, skStr, //字符串 hex|base58  (err, tx) =\u0026gt; { if (err) { console.error(err) } else { console.log(tx) } } ) 注意\r#\r\r 签名程序会根据当前机器的性能决定并行计算的数量，交易生成时间与引用的UTXO的数量成正比。  如果花费的UTXO的个数很多，生成时间会变得非常长。   解决方案  对于在线签名应用  对充值进来的UTXO进行merge。  zro 的 exchange 服务提供了自动 merge 功能，在zro上增加 —autoMerge 则可以自动进行UTXO的合并。   可以延长接口调用的超时时间。  --rpcwritetimeout [SECOND] 启动zro的时候加上这个参数，可以设置zro回写的超时时间，单位是秒。     对于离线签名应用  并行运行多个签名 利用genMergeTx生成离线签名交易参数，再进行离线签名后发送。      导入账户\r#\r\r zro有两种导入账户的方式，分别是导入 seed 和导入 TK ，导入 TK 之后的zro只能用来跟踪账户的余额和充值记录或者是产生收款码，产生的交易必须经过离线签名之后才能提交到链上。导入 seed 则可以直接使用zro来签名交易。\n  导入 seed\n 利用助记词导入 seed，在web3里面：  \u0026gt; personal.importMnemonic(\u0026#34;uncle frost ex.....ion before\u0026#34;,\u0026#34;123456\u0026#34;) //助记词,密码 \u0026#34;GwA94QDTyQ86cE5jcu......aZPRMUwR8k5uW4bT3DvPf77a5\u0026#34; //公钥PK  导出seed对应的助记词是  \u0026gt; personal.exportMnemonic(zorro.accounts[0],\u0026#34;123456\u0026#34;) //公钥PK，密码 \u0026#34;uncle frost expose ...... salmon champion before\u0026#34;  直接导入hex编码的 seed (32 bytes 随机数)  \u0026gt; personal.importRawKey( \u0026#34;ec8bad429641f......0b1ab03d1f\u0026#34;, //Seed  \u0026#34;123456\u0026#34;, //密码  1, //协议版本 1: SuperZK1.0，2: SuperZK2.0  1800000 //账户从1800000块开始进行余额分析 ) \u0026#34;GwA94QDTyQ86cE5jc......8k5uW4bT3DvPf77a5\u0026#34; //公钥PK  导出hex编码的 seed，需要已经导入过这个账户。  \u0026gt;personal.exportRawKey(\u0026#34;GwA94QDTyQ86cE5j....DvPf77a5\u0026#34;,\u0026#34;123456\u0026#34;) //公钥PK，密码  然后用accounts可以查看到导入账户的公钥  \u0026gt; zorro.accounts [\u0026#34;GwA94QDTyQ86cE5jcuYCyrQ9Bu9FRcXfq4dxQhryTDzhkahUjYSHcjZ5yFF9bvaZPRMUwR8k5uW4bT3DvPf77a5\u0026#34;]   导入 TK，只能查看和跟踪交易和余额，不能发送交易。\n\u0026gt; personal.importTk( \u0026#34;GwA94QDTyQ86cE5......AwUB22sEmQQ1AguYXn\u0026#34;, //TK  1800000 //账户从1800000块开始分析  ) \u0026#34;GwA94QDTyQ86cE5jcuYCyr......bvaZPRMUwR8k5uW4bT3DvPf77a5\u0026#34; //公钥PK  查看账户的 TK  \u0026gt; zorro.getTk(zorro.accounts[0]) //公钥PK \u0026#34;GwA94QDTyQ86cE5jcuYCy.......AwUB22sEmQQ1AguYXn\u0026#34; //TK   导入账户之后，exchange服务就会自动分析区块信息，如果是新导入的账户，服务需要一段时间才能分析到最新块。可以通过查看zro的日志看出是否分析完毕。\n 需要开启 —exchange 标记  INFO [06-13|15:44:00.016] Exchange indexed blockNumber=1031753 INFO [06-13|15:44:50.007] Exchange indexed blockNumber=1031754 INFO [06-13|15:45:00.007] Exchange indexed blockNumber=1031755 INFO [06-13|15:45:10.007] Exchange indexed blockNumber=1031756 不管是导入 seed 还是 TK ，zro 都会为它生成一个keystore，其中 seed 以密文的形式存储，TK 以明文的形式存储。\n  导入账户后，exchange分析会从第1块开始，为了避免exchange分析时间过长，用户可以：\n 通过修改keystore文件里面的自动跳过没有必要分析的块数  { \u0026#34;address\u0026#34;:\u0026#34;24DidZ7...KWTQtU8\u0026#34;, \u0026#34;tk\u0026#34;:\u0026#34;24Did...BaG84r\u0026#34;, \u0026#34;crypto\u0026#34;:{ \u0026#34;cipher\u0026#34;:\u0026#34;aes-128-ctr\u0026#34;, \u0026#34;ciphertext\u0026#34;:\u0026#34;4e4b3247...adbff2\u0026#34;, \u0026#34;cipherparams\u0026#34;:{\u0026#34;iv\u0026#34;:\u0026#34;1d13d245...3f9db2\u0026#34;}, \u0026#34;kdf\u0026#34;:\u0026#34;scrypt\u0026#34;, \u0026#34;kdfparams\u0026#34;:{\u0026#34;dklen\u0026#34;:32,\u0026#34;n\u0026#34;:262144,\u0026#34;p\u0026#34;:1,\u0026#34;r\u0026#34;:8,\u0026#34;salt\u0026#34;:\u0026#34;e17991a97...b1b7bd\u0026#34;}, \u0026#34;mac\u0026#34;:\u0026#34;b66f0c...2dd7d06\u0026#34; }, \u0026#34;id\u0026#34;:\u0026#34;f939...28c\u0026#34;, \u0026#34;version\u0026#34;:1, \u0026#34;at\u0026#34;:1050000 //增加at自动，自动跳过之前的 1~1050000 块 }  或者在导入账户的时候提供at参数。    离线接口的rpc版本\r#\r\r 目前离线api接口提供了go和javascript两种语言，其他语言可以通过启动一个不对外连接的zro，通过rpc来使用这些功能。\n  seed 生成 sk\nexchange.seed2Sk( \u0026#34;0xec8bad429......0b1ab03d1f\u0026#34;, //seed: hex编码  1 //SuperZK协议版本 1：1.0 2：2.0 ) \u0026#34;0x8fe1c73ac......0d1bc4305\u0026#34; //sk: hex 编码   sk 生成 TK\nexchange.sk2Tk(\u0026#34;0x8fe1c7......40d1bc4305\u0026#34;) //sk: hex编码 \u0026#34;GwA94QDTy......QQ1AguYXn\u0026#34; //TK: base58 编码   TK 生成 PK\nexchange.tk2Pk( \u0026#34;GwA94QDTyQ86c......1AguYXn\u0026#34;, //TK: hex或者base58 编码 ) \u0026#34;GwA94QDTyQ8......uW4bT3DvPf77a5\u0026#34; //PK: base58 编码   PK 生成 PKr\n\u0026gt; exchange.pk2Pkr( \u0026#34;GwA94QDTyQ8......uW4bT3DvPf77a5\u0026#34;, //PK  \u0026#34;0x000000000......0000110\u0026#34; //32 byte 的随机数，为空则自动生成。 ) \u0026#34;22mZ61am......aevRpWMD89\u0026#34; //PKr: base58 编码   离线签名\n\u0026gt; const sk = \u0026#39;0xfd1b401d2bbf......71a4b080977\u0026#39; //私钥 SK: hex 编码 \u0026gt; const txParamObj = {\u0026#34;Gas\u0026#34;:25000,\u0026#34;GasPrice\u0026#34;:1000000000,.... } //由全节点构造(不是字符串) \u0026gt; var tx = exchange.signTxWithSk(txParamObj,sk)   钱包接口\r#\r\r ZORRO的全节点程序(zro)提供了一套专门为exchange对接的服务，exchange使第三方对接更加简单。对接方可以在只导入账户的 TK 的情况下 ，获取链上跟账户相关余额和记录信息。接口支持jsonrpc和console两种方式。\n开启全节点(zro)的exchange服务\r#\r\r  在启动zro的时候添加 —exchange 以及 --rpcapi exchange,zorro 两个参数即可开启zro的exchange服务。\n --exchange 开启exchange服务 --rpcapi zorro,exchange 开启exchange和zorro的jsonrpc接口 其他的rpc参数与以太坊一致    为了在算力大幅度波动的时候确保安全，可以设置确认的区块数量。\n --confirmedBlock 32 设置32个块确认交易，默认为12个块。    ZORRO的rpc有请求大小的限制，默认为512K。\n --rpcRequestContentLength 1048576 可以将限制改为1M    如果无法在jsonrpc返回值序列化的时候处理bigint类型，可以使jsonrpc以字符串的形式返回数值。\n --exchangeValueStr 将使zro的jsonrpc接口以字符串的形式返还数值。    zro为了尽可能少的在硬盘上存储数据，目前每10000块或者1小时保存一次快照，因此当zro关闭后，会从最近的1万的整数倍块开始同步。\n --gcmode archive 将使zro每一块都保存快照数据，重启的时候不会回滚区块。但是这种方式会耗费更大的硬盘存储。    zro在utxo个数较多的时候签名会消耗较多的时间，因此可以调整zro回写client的超时时间\n --rpcwritetimeout [SECOND] 启动zro的时候加上这个参数，可以设置zro回写的超时时间，单位是秒。    启动参数示例\n./zro --exchange --datadir ~/zroData --port 53717 --rpc --rpcport 8545 --rpcapi exchange,zorro,net --rpcaddr 127.0.0.1 --rpccorsdomain \u0026#34;*\u0026#34; --keystore ~/keystore --confirmedBlock 32 --rpcwritetimeout 1800 --exchangeValueStr  对接方可以根据需求修改上面的配置    接口简介\r#\r\r ZORRO提供的exchange接口  GetBlockByNumber(num)-\u0026gt;block  获取块的基本信息 也可以使用zorro.GetBlockByNumer获取更详细信息，使用方式跟以太坊兼容   GetBlocksInfo(start,end)-\u0026gt;blocks  获取start~end之间块的详情   GetPkr(pk,rnd)-\u0026gt;pkr  通过公钥 pk 和随机数 rnd 生成收款码 pkr zorro.GenPKr(pk)-\u0026gt;pkr可以生成随机的 pkr   GetPkByPkr(pkr)-\u0026gt;pk  通过收款码pkr反查pk pk对应的账户必须在zro中   GetBalances(pk)-\u0026gt;balances  通过公钥 pk 获取总余额 balances   GetRecords(begin,end,[pk])-\u0026gt;[]Utxo  获取账户pk在块号begin 到 end 之间的充值进来的 UTXO。   GenTx(preTxParam)-\u0026gt;txParam  通过preTxParam获取可以用来签名的txParam。   GenMergeTx(mergeParam)-\u0026gt;txParam  根据参数mergeParam生成合并的交易参数txParam，txParam需要离线签名。   GetTx(txhash)-\u0026gt;tx  获取交易hash对应的细节 目前只提供入账记录   GenTxWithSign(preTxParam)-\u0026gt;tx  通过preTxParam直接生成签名后的tx 账户需要导入seed   CommitTx(tx)-\u0026gt;()  将签名好的tx提交给交易池并广播给全网   GetPkSynced(pk)-\u0026gt;pkState  获取当前exchange的账户分析情况   Merge(pk,currency)-\u0026gt;txhash  在线签名 自动合并币种currency的 UTXO 目标值是少于10个 UTXO   ValidAddress(pk|pkr)-\u0026gt;bool  检查PK或者PKr是否合法   GetLockedBalances(pk)-\u0026gt;lockedState  检查由于生成交易可能导致的锁定金额   GetMaxAvailable(pk,currency)-\u0026gt;value  获取币种currency当前能发送的最大的金额   ClearUsedFlag(pk)-\u0026gt;()  清除PK下 由于发送交易锁定UTXO的标记   ClearUsedFlagForRoot([root,...])-\u0026gt;()  清除 root 代表的UTXO的锁定标记      GetBlockByNumber\r#\r\r  根据块号获取当前块的信息\n  jsonrpc\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;exchange_getBlockByNumber\u0026#34;, \u0026#34;params\u0026#34;: [ 109 // 块号，空代表获取最新的块。  ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { \u0026#34;BlockHash\u0026#34;:\u0026#34;0x61de8473709....3172c2225e55\u0026#34;， //块hash  \u0026#34;BlockNumber\u0026#34;: 109, //块号  \u0026#34;ParentHash\u0026#34;: \u0026#34;0xaf5f6bf0814203a8b49fc3398489e029dd4e9e5da45be241d3f85fc234f341aa\u0026#34; \u0026#34;timestamp\u0026#34;: 1561398077 //时间戳  \u0026#34;TxHashes\u0026#34;: [ //交易hash列表  \u0026#34;0xc31c834efe568d56e7b4c60e7aefe2b223e8567244f242c7870ec5cb47cc1000\u0026#34;, \u0026#34;0x9123159d7016086ed4e1ec253f575cd38f04cc4dea31ce922d1387c985e336c8\u0026#34; ] } \u0026#34;error\u0026#34;: null }   console\n  \u0026gt; exchange.getBlockByNumber(109) { \u0026#34;hash\u0026#34;:\u0026#34;0x61de8473709567be5278c2e607915e6f9001f45f51dc94f8792a3172c2225e55\u0026#34;， \u0026#34;number\u0026#34;: 109, \u0026#34;timestamp\u0026#34;: 1561398077, \u0026#34;TxHashes\u0026#34;: [ \u0026#34;0xc31c834efe568d56e7b4c60e7aefe2b223e8567244f242c7870ec5cb47cc1000\u0026#34;, \u0026#34;0x9123159d7016086ed4e1ec253f575cd38f04cc4dea31ce922d1387c985e336c8\u0026#34; ] } GetBlocksInfo\r#\r\r  获取一个范围内的块对UTXO的使用信息\n  jsonrpc\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;exchange_getBlocksInfo\u0026#34;, \u0026#34;params\u0026#34;: [ 108, // 开始块号  109 // 结束块号  ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { [ { BlockHash: \u0026#34;0x42fee36......d82bd53\u0026#34;, // 块Hash  Ins: [\u0026#34;0xd85......e0d597\u0026#34;], // 本块花费的UTXO的root  BlockNumber: 108, // 块高度  Outs: [{ Currency: \u0026#34;ZORRO\u0026#34;, Nil: \u0026#34;0xe1d29......d15d89\u0026#34;, Num: 108, Pkr: \u0026#34;0x842e......950d\u0026#34;, Root: \u0026#34;0x192717......646d42a\u0026#34;, TxHash: \u0026#34;0xf8f2269......66d181\u0026#34;, Value: 70000000000000000000 }, ...... ] } ] } \u0026#34;error\u0026#34;: null }   console\n  \u0026gt; exchange.getBlocksInfo(108,109) { [ { BlockHash: \u0026#34;0x42fee36......d82bd53\u0026#34;, Ins: [\u0026#34;0xd85......e0d597\u0026#34;], BlockNum: 108, Outs: [{ Currency: \u0026#34;ZORRO\u0026#34;, Nil: \u0026#34;0xe1d29......d15d89\u0026#34;, Num: 108, Pkr: \u0026#34;0x842e......950d\u0026#34;, Root: \u0026#34;0x192717......646d42a\u0026#34;, TxHash: \u0026#34;0xf8f2269......66d181\u0026#34;, Value: 70000000000000000000 }, ...... ] } ] } GetPkr\r#\r\r  采用随机数创建PK对应的PKr\n  jsonrpc\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;exchange_getPkr\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0x0dbd9c096......32a20849304201ea6\u0026#34;, //PK的hex编码  \u0026#34;0x000000000......00000000000000101\u0026#34; //32BYTE的随机数，需 \u0026gt; 0x100  ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: \u0026#34;0x8423cdaf21db11......d1c76e728630a882a14\u0026#34;, //PKr  \u0026#34;error\u0026#34;: null }   console\n  \u0026gt; exchange.getPkr(zorro.accounts[0],\u0026#34;0x000000000......00000000000000100\u0026#34;) \u0026#34;0x4546ffe8932.......88efeead5d7a84\u0026#34; GetPkByPkr\r#\r\r  获取PKr在zro中对应的PK\n  jsonrpc\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;exchange_getPkByPkr\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0xa01b191......ad09bf320\u0026#34; //收款码Pkr的hex编码  ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: \u0026#34;0xc3863f5......bce8168a87\u0026#34;, //公钥Pk  \u0026#34;error\u0026#34;: null }   console\n  \u0026gt; exchange.getPkByPkr(\u0026#34;0xa01b191......ad09bf320\u0026#34;) \u0026#34;0xc3863f5......bce8168a87\u0026#34; GetBalances\r#\r\r  获取PK代表的账户当前的总余额\n  jsonrpc\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;exchange_getBalances\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0x0dbd9c096ca52fa44570......58332a20849304201ea6\u0026#34; //公钥 PK  ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { \u0026#34;tkn\u0026#34; : { \u0026#34;ZORRO\u0026#34;: 4000000000000000000 //币种名 : 余额  }, \u0026#34;tkt\u0026#34; : {} }, \u0026#34;error\u0026#34;: null }   console\n  \u0026gt; exchange.getBalances(web3.addressToHex(zorro.accounts[0])) { ZORRO: 169900000000000000000 } GetRecords\r#\r\r  获取充值记录\n  jsonrpc\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;exchange_getRecords\u0026#34;, \u0026#34;params\u0026#34;: [ 1, // 开始的块号  1000， // 结束的块号  \u0026#34;0x0dbd9c096......849304201ea6\u0026#34;, // 收款码(PKr)|账户公钥(PK)|留空  ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: [ //充值的UTXO列表  { \u0026#34;Pkr\u0026#34;: \u0026#34;0x67dc2f42a063477a7ef......1fbbfd8707b0cd449994\u0026#34;, \u0026#34;Root\u0026#34;: \u0026#34;0x13ca7a02c8......8e85b08775a3706b0\u0026#34;, //UTXO的唯一标识  \u0026#34;TxHash\u0026#34;: \u0026#34;0x000000000000000......00000000000000000000\u0026#34;, //UTXO所在的Tx的hash  \u0026#34;Nil\u0026#34;: \u0026#34;0x902953f4eaec70e......b09beb8fff798a0d59ec23\u0026#34;, //UTXO的作废码  \u0026#34;Num\u0026#34;: 1, //UTXO所在的块高度  \u0026#34;Currency\u0026#34;: \u0026#34;ZORRO\u0026#34;, //币名  \u0026#34;Value\u0026#34;: \u0026#34;1000000000000000000\u0026#34; //币的数量  }, { \u0026#34;Pkr\u0026#34;: \u0026#34;0x291560a9ad4db22df......7bef504d7c7544dbddabcce6e79f0b\u0026#34;, \u0026#34;Root\u0026#34;: \u0026#34;0xa9623b4c88f53e......09522c831bf508834be8a7\u0026#34;, \u0026#34;TxHash\u0026#34;: \u0026#34;0x0dd3a111270......7da11af453498\u0026#34;, \u0026#34;Nil\u0026#34;: \u0026#34;0xa6acfbc53cf68c433......0a1c0b974ad55977048069f\u0026#34;, \u0026#34;Num\u0026#34;: 2, \u0026#34;Currency\u0026#34;: \u0026#34;ZORRO\u0026#34;, //币名  \u0026#34;Value\u0026#34;: \u0026#34;1000000000000000000\u0026#34; //币的数量  }, ...... ], \u0026#34;error\u0026#34;: null }   console\n  \u0026gt; exchange.getRecords(1,3,zorro.accounts[0]) [ { Currency: \u0026#34;ZORRO\u0026#34;, Nil: \u0026#34;0x5b3d....b0b328\u0026#34;, Num: 1, Pkr: \u0026#34;0x5e3f88....1ee14\u0026#34;, Root: \u0026#34;0xd79e00....250bc96\u0026#34;, TxHash: \u0026#34;0x000000000......00000000000\u0026#34;, Value: \u0026#34;17600000000000000000\u0026#34; }, ...... ] GenTx\r#\r\r 离线签名版本的交易生成 ZORRO对交易的输入和输出个数有限制  明文输出不超过10个，密文输出不超过500个 明文输入不超过2500个，密文输入没有限制  可以通过API GetMaxAvailable 获取当前能发送的最大金额   每次调用GenTx，会轮换着使用UTXO，并且将UTXO记下来。  GetLockedBalances可以查询已经锁定的金额大小        jsonrpc\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;exchange_genTx\u0026#34;, \u0026#34;params\u0026#34;: [{ \u0026#34;From\u0026#34;: \u0026#34;0x0dbd9c0......9304201ea6\u0026#34;, //账户的PK  \u0026#34;RefundTo\u0026#34;: \u0026#34;0x8423cdaf......630a882a14\u0026#34;, //可选，找零收款码(PKr)，为空则自动生成。  \u0026#34;Gas\u0026#34;: 25000, //最大消耗Gas，最少25000  \u0026#34;GasPrice\u0026#34;: 1000000000, //GasPrice，默认1Gta  \u0026#34;Cmds\u0026#34;: { //可选，执行命令参数 (\u0026gt;=v1.0.0-rc6)  \u0026#34;BuyShare\u0026#34;: { //购买股份(以From为资金账户)  \u0026#34;Value\u0026#34;: \u0026#34;2000000000000000000\u0026#34;, //购买金额，单位Ta  \u0026#34;Vote\u0026#34;: \u0026#34;0x8423cdaf......630a882a14\u0026#34;, //SOLO 投票地址  \u0026#34;Pool\u0026#34;: \u0026#34;0x8414cdd......9df62dbda25b\u0026#34; //可选，StakingNode ID  }, \u0026#34;Contract\u0026#34;: { //调用智能合约  \u0026#34;Currency\u0026#34;: \u0026#34;ZORRO\u0026#34;, //传入资产的币种  \u0026#34;Value\u0026#34;: \u0026#34;1000000000\u0026#34;, //传入资产的金额，单位Ta  \u0026#34;To\u0026#34;: \u0026#34;0x59bd488f......4e16a2e2b0\u0026#34;, //合约地址，为空则是创建智能合约  \u0026#34;Data\u0026#34;: \u0026#34;0x233892....228efad\u0026#34; //智能合约的Data  } }, \u0026#34;Receptions\u0026#34;: [{ //接受者信息  \u0026#34;Addr\u0026#34;: \u0026#34;0x8423cdaf......630a882a14\u0026#34;, //接受者PKr|PK，PK会自动转成PKr  \u0026#34;Currency\u0026#34;: \u0026#34;ZORRO\u0026#34;, //币名  \u0026#34;Value\u0026#34;: 900000000000000000 //币的数量  }], \u0026#34;Roots\u0026#34;: [] //需要使用哪些UTXO，空值代表自动选择。  }] }  response  这个方法返回的结构比较复杂，可以直接将 result 传给离线客户端进行签名即可。\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { \u0026#34;Gas\u0026#34;: 25000, \u0026#34;GasPrice\u0026#34;: 1000000000, \u0026#34;From\u0026#34;: { \u0026#34;SKr\u0026#34;: \u0026#34;0x00000000......00000000000\u0026#34;, \u0026#34;PKr\u0026#34;: \u0026#34;0xb28e17a7......ad09bf320\u0026#34; }, \u0026#34;Ins\u0026#34;: [{ \u0026#34;SKr\u0026#34;: \u0026#34;0x00000000......00000000000\u0026#34;, \u0026#34;Out\u0026#34;: { \u0026#34;Root\u0026#34;: \u0026#34;0x13ca7a0......75a3706b0\u0026#34;, \u0026#34;State\u0026#34;: { \u0026#34;OS\u0026#34;: { \u0026#34;Index\u0026#34;: 1, \u0026#34;Out_O\u0026#34;: { \u0026#34;Addr\u0026#34;: \u0026#34;0x67dc2f42a063......b0cd449994\u0026#34;, \u0026#34;Asset\u0026#34;: { \u0026#34;Tkn\u0026#34;: { \u0026#34;Currency\u0026#34;: \u0026#34;0x0000000......0000005345524f\u0026#34;, \u0026#34;Value\u0026#34;: 1000000000000000000 }, \u0026#34;Tkt\u0026#34;: null }, \u0026#34;Memo\u0026#34;: \u0026#34;0x00000000......0000000000\u0026#34; }, \u0026#34;Out_Z\u0026#34;: null, \u0026#34;OutCM\u0026#34;: \u0026#34;0xedfe90dbc76......c7e2454371e22\u0026#34;, \u0026#34;RootCM\u0026#34;: \u0026#34;0xe07a24781......1d037f9412c23\u0026#34; }, \u0026#34;TxHash\u0026#34;: \u0026#34;0x0000000000......000000000000\u0026#34;, \u0026#34;Num\u0026#34;: 1 } }, \u0026#34;Witness\u0026#34;: { \u0026#34;Pos\u0026#34;: \u0026#34;0x1\u0026#34;, \u0026#34;Paths\u0026#34;: [\u0026#34;0xea8a7fa27d4c......565c0ca6bf7a8\u0026#34;, \u0026#34;0x2e6831a00874......35c4d21d5cd07\u0026#34;, \u0026#34;0x7812d8320911.......1435b58078af\u0026#34;, \u0026#34;0x47f3115ed518.......29feed9d623\u0026#34; ...... ], \u0026#34;Anchor\u0026#34;: \u0026#34;0xa9623b4c88......508834be8a7\u0026#34; } }], \u0026#34;Outs\u0026#34;: [{ \u0026#34;PKr\u0026#34;: \u0026#34;0x8423cdaf21d......630a882a14\u0026#34;, \u0026#34;Asset\u0026#34;: { \u0026#34;Tkn\u0026#34;: { \u0026#34;Currency\u0026#34;: \u0026#34;0x000......005345524f\u0026#34;, \u0026#34;Value\u0026#34;: 900000000000000000 }, \u0026#34;Tkt\u0026#34;: null }, \u0026#34;Memo\u0026#34;: \u0026#34;0x000000......0000000\u0026#34; }, { \u0026#34;PKr\u0026#34;: \u0026#34;0xb28e17a7d1d......4b740ad09bf320\u0026#34;, \u0026#34;Asset\u0026#34;: { \u0026#34;Tkn\u0026#34;: { \u0026#34;Currency\u0026#34;: \u0026#34;0x000000......0005345524f\u0026#34;, \u0026#34;Value\u0026#34;: 99975000000000000 }, \u0026#34;Tkt\u0026#34;: null }, \u0026#34;Memo\u0026#34;: \u0026#34;0x00000000......000000000\u0026#34; }] }, \u0026#34;error\u0026#34;: null }   console\n  var txParam = exchange.genTx({ \u0026#34;From\u0026#34;: web3.addressToHex(zorro.accounts[0]), \u0026#34;Gas\u0026#34;: 25000, \u0026#34;GasPrice\u0026#34;: 1000000000, \u0026#34;Receptions\u0026#34;: [{ \u0026#34;Addr\u0026#34;: web3.addressToHex(zorro.genPKr(zorro.accounts[1])), \u0026#34;Currency\u0026#34;: \u0026#34;ZORRO\u0026#34;, \u0026#34;Value\u0026#34;: web3.toTa(1) }], \u0026#34;Roots\u0026#34;: [] }) // txParam 与 jsonrpc 的返回结果一致 GenMergeTx\r#\r\r  离线签名版本的UTXO合并\n  jsonrpc\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;exchange_genMergeTx\u0026#34;, \u0026#34;params\u0026#34;: [{ \u0026#34;From\u0026#34;: \u0026#34;0x0dbd9c0......9304201ea6\u0026#34;, //账户的PK  \u0026#34;To\u0026#34;: \u0026#34;0x8423cdaf......630a882a14\u0026#34;, //合并到收款码(PKr)，为空则自动生成。  \u0026#34;Currency\u0026#34;: \u0026#34;ZORRO\u0026#34;, //需要合并的币名  \u0026#34;Zcount\u0026#34;: 100, //最大合并的密文UTXO个数  \u0026#34;Icount\u0026#34;: 1000, //最多一次合并UTXO的个数  \u0026#34;Left\u0026#34;: 1 //剩下多少个UTXO  }] }   response\n同genTx\n    console\n  var txParam = exchange.genMergeTx({ \u0026#34;From\u0026#34;: web3.addressToHex(zorro.accounts[0]), \u0026#34;To\u0026#34;: \u0026#34;0x8423cdaf......630a882a14\u0026#34;, \u0026#34;Currency\u0026#34;: \u0026#34;ZORRO\u0026#34;, \u0026#34;Zcount\u0026#34;: 100, \u0026#34;Left\u0026#34;: 1 }) // txParam 与 jsonrpc 的返回结果一致 GetTx\r#\r\r  获取交易详情\n  jsonrpc\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;exchange_getTx\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0xf8f2269......66d181\u0026#34; //交易Hash  ] }   response\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { BlockHash: \u0026#34;0x42fee3......d82bd53\u0026#34;, //块Hash  BlockNumber: 108, //块号  Outs: [ { //Out列表  Currency: \u0026#34;ZORRO\u0026#34;, //币名  PK: \u0026#34;0x40aa8......f4d08a96\u0026#34;, //账户公钥  Pkr: \u0026#34;0x924f6b6c......09bf320\u0026#34;, //收款码  Root: \u0026#34;0x0d57fa92.....879d811\u0026#34;, //Root  Value: 4999925000000000000 //金额  }, ...... ], Ins: [ //交易输入UTXO的Root列表  \u0026#34;0x0dbd9c0......9304201ea6\u0026#34; ], TxHash: \u0026#34;0xf8f2269......66d181\u0026#34; //交易hash  Fee: 25000000000000, //gas费用  Timestamp: 1561442217 //交易的时间戳  }, \u0026#34;error\u0026#34;: null }      console\n  \u0026gt; exchange.getTx(\u0026#34;0xf8f2269......66d181\u0026#34;) { BlockHash: \u0026#34;0x42fee3......d82bd53\u0026#34;, BlockNumber: 108, Outs: [ { Currency: \u0026#34;ZORRO\u0026#34;, PK: \u0026#34;0x40aa8......f4d08a96\u0026#34;, Pkr: \u0026#34;0x924f6b6c......09bf320\u0026#34;, Value: 4999925000000000000 }, ...... ], TxHash: \u0026#34;0xf8f2269......66d181\u0026#34; } GenTxWithSign\r#\r\r  在线版本的交易生成\n  jsonrpc\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;exchange_genTxWithSign\u0026#34;, \u0026#34;params\u0026#34;: [{ \u0026#34;From\u0026#34;: \u0026#34;0x0dbd9c0......9304201ea6\u0026#34;, //账户的PK  \u0026#34;RefundTo\u0026#34;: \u0026#34;0x8423cdaf......630a882a14\u0026#34;, //找零收款码(PKr)，为空则自动生成。  \u0026#34;Gas\u0026#34;: 25000, //最大消耗Gas，最少25000  \u0026#34;GasPrice\u0026#34;: 1000000000, //GasPrice，默认1Gta  \u0026#34;Receptions\u0026#34;: [{ //接受者信息  \u0026#34;Addr\u0026#34;: \u0026#34;0x8423cdaf......630a882a14\u0026#34;, //接受者PKr  \u0026#34;Currency\u0026#34;: \u0026#34;ZORRO\u0026#34;, //币名  \u0026#34;Value\u0026#34;: 900000000000000000 //币的数量  }], \u0026#34;Roots\u0026#34;: [] //需要使用哪些UTXO，空值代表自动选择。  }] }  response  签名后的数据可以直接提交给CommitTx发送到全网，同时 GenTx之后再进行离线签名的结果跟GenTxWithSign的result是一致的。\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { \u0026#34;Gas\u0026#34;: \u0026#34;0x61a8\u0026#34;, \u0026#34;GasPrice\u0026#34;: \u0026#34;0x3b9aca00\u0026#34;, \u0026#34;Tx\u0026#34;: { \u0026#34;Ehash\u0026#34;: \u0026#34;0x59bd488......16a2e2b0\u0026#34;, \u0026#34;From\u0026#34;: \u0026#34;0xb28e17a7......d09bf320\u0026#34;, \u0026#34;Fee\u0026#34;: { \u0026#34;Currency\u0026#34;: \u0026#34;0x00000000000......05345524f\u0026#34;, \u0026#34;Value\u0026#34;: 25000000000000 }, \u0026#34;Sign\u0026#34;: \u0026#34;0x7937304f......8fe12d803\u0026#34;, \u0026#34;Bcr\u0026#34;: \u0026#34;0x576cc80af......fc35a82\u0026#34;, \u0026#34;Bsign\u0026#34;: \u0026#34;0xea0c7a......2aadcb801\u0026#34;, \u0026#34;Desc_Z\u0026#34;: { \u0026#34;Ins\u0026#34;: null, \u0026#34;Outs\u0026#34;: [{ \u0026#34;AssetCM\u0026#34;: \u0026#34;0x23b24db7363......af614d40861f28\u0026#34;, \u0026#34;OutCM\u0026#34;: \u0026#34;0x16653600938......cde422f18ac00\u0026#34;, \u0026#34;RPK\u0026#34;: \u0026#34;0xc5740db4......4efa5411d9\u0026#34;, \u0026#34;EInfo\u0026#34;: \u0026#34;0x1f0d1dc5f......df00209c22\u0026#34;, \u0026#34;PKr\u0026#34;: \u0026#34;0x8423cda.......630a882a14\u0026#34;, \u0026#34;Proof\u0026#34;: \u0026#34;0x030d19322......c16ba7104\u0026#34; }, { \u0026#34;AssetCM\u0026#34;: \u0026#34;0x73280eb9......9d6d5f042c\u0026#34;, \u0026#34;OutCM\u0026#34;: \u0026#34;0x92cace7c......1a5a528c\u0026#34;, \u0026#34;RPK\u0026#34;: \u0026#34;0x8126a4......06607d0ee\u0026#34;, \u0026#34;EInfo\u0026#34;: \u0026#34;0x5fa2c37......5101d8f3\u0026#34;, \u0026#34;PKr\u0026#34;: \u0026#34;0xb28e1......09bf320\u0026#34;, \u0026#34;Proof\u0026#34;: \u0026#34;0x026a8c617......829600c\u0026#34; }] }, \u0026#34;Desc_O\u0026#34;: { \u0026#34;Ins\u0026#34;: [{ \u0026#34;Root\u0026#34;: \u0026#34;0x13ca7a0......75a3706b0\u0026#34;, \u0026#34;Nil\u0026#34;: \u0026#34;0xc179f8......9acf98d\u0026#34;, \u0026#34;Sign\u0026#34;: \u0026#34;0xa4ef43839......eb19b6a3701\u0026#34; }], \u0026#34;Outs\u0026#34;: null }, \u0026#34;Desc_Pkg\u0026#34;: { \u0026#34;Create\u0026#34;: null, \u0026#34;Transfer\u0026#34;: null, \u0026#34;Close\u0026#34;: null } }, \u0026#34;Hash\u0026#34;: \u0026#34;0x0dd3a1112......11af453498\u0026#34;, //交易Hash  \u0026#34;Roots\u0026#34;: [\u0026#34;0x13ca7a0......75a3706b0\u0026#34;] //输入的UTXO的Root列表 v1.0.0-rc7  }, \u0026#34;error\u0026#34;: null }   console\n  \u0026gt; personal.unlockAccount(zorro.accounts[0],\u0026#34;123456\u0026#34;) true \u0026gt; var tx = exchange.genTxWithSign({ \u0026#34;From\u0026#34;: web3.addressToHex(zorro.accounts[0]), \u0026#34;Gas\u0026#34;: 25000, \u0026#34;GasPrice\u0026#34;: 1000000000, \u0026#34;Receptions\u0026#34;: [{ \u0026#34;Addr\u0026#34;: \u0026#34;0x4546ffe893......eead5d7a84\u0026#34;, \u0026#34;Currency\u0026#34;: \u0026#34;ZORRO\u0026#34;, \u0026#34;Value\u0026#34;: web3.toTa(1) }], \u0026#34;Roots\u0026#34;: [] }) //tx 与 jsonrpc 返回的 result 一致 CommitTx\r#\r\r  提交签名后的交易到交易池\n  jsonrpc\n  request\n  跟GenTxWithSign的输出一致\n  response\n 无错误就说明已经放到交易池，等待zro同步到全网。      console\n  \u0026gt; exchange.commitTx(tx) //tx 是 `GenTxWithSign` 或者离线签名的结果 null \u0026gt; zorro.getTransactionReceipt(tx.Hash) { blockHash: \u0026#34;0x780cb2866......d27218ff8e\u0026#34;, blockNumber: 107, contractAddress: null, cumulativeGasUsed: 25000, from: \u0026#34;24WSzZB......gkeQJtGP\u0026#34;, gasUsed: 25000, logs: [], logsBloom: \u0026#34;0x00000000......000000000\u0026#34;, root: \u0026#34;0x06414dcf......78ea7c4218\u0026#34;, status: \u0026#34;0x1\u0026#34;, to: null, transactionHash: \u0026#34;0x1bae9132......7ecd7172d36\u0026#34;, transactionIndex: 0 } GetPkSynced\r#\r\r  exchange当前的分析进度\n  jsonrpc\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;exchange_getPkSynced\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0x0dbd9c0......9304201ea6\u0026#34;, //账户的PK  ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { \u0026#39;currentBlock\u0026#39;: 121, //当前块高度  \u0026#39;currentPKBlock\u0026#39;: 121, //exchange分析到的块高度  \u0026#39;highestBlock\u0026#39;: 121 //全网当前块高度  \u0026#39;utxoCount\u0026#39;: { \u0026#39;ZORRO\u0026#39;:100 //ZORRO当前UTXO的数量，需要先调用getBalances  } }, \u0026#34;error\u0026#34;: null }   console\n  \u0026gt; exchange.getPkSynced(\u0026#34;0x0dbd9c0....9304201ea6\u0026#34;) { currentBlock: 121, currentPKBlock: 121, highestBlock: 121 } Merge\r#\r\r  在线签名版本的UTXO合并\n  jsonrpc\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;exchange_merge\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0x0dbd9c0......9304201ea6\u0026#34;, //账户的PK  \u0026#34;ZORRO\u0026#34;\t//Merge的币种  ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { \u0026#34;0x1bae9132......7ecd7172d36\u0026#34; //Merge生成的交易Hash  }, \u0026#34;error\u0026#34;: null }   console\n  \u0026gt; exchange.merge(\u0026#34;0x0dbd9c0......9304201ea6\u0026#34;,\u0026#34;ZORRO\u0026#34;) \u0026#34;0x1bae9132......7ecd7172d36\u0026#34; ValidAddress\r#\r\r  判断PK或PKr是否有效\n  jsonrpc\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;exchange_validAddress\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0x0dbd9c0......9304201ea6\u0026#34; //账户的PK或者PKr  ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { true //是否有效  }, \u0026#34;error\u0026#34;: null }   console\n  \u0026gt; exchange.validAddress(\u0026#34;0x0dbd9c0......9304201ea6\u0026#34;) true GetLockedBalances\r#\r\r  获取被锁定的金额\n  jsonrpc\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;exchange_getLockedBalances\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0x0dbd9c0......9304201ea6\u0026#34; //账户的PK  ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { \u0026#34;ZORRO\u0026#34;:7000 //可能被锁定的金额  }, \u0026#34;error\u0026#34;: null }   console\n  \u0026gt; exchange.getLockedBalances(\u0026#34;0x0dbd9c0......9304201ea6\u0026#34;) { \u0026#34;ZORRO\u0026#34;:7000 } GetMaxAvailable\r#\r\r  获取当前能转出的最大金额\n  jsonrpc\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;exchange_getMaxAvailable\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0x0dbd9c0......9304201ea6\u0026#34;, //账户的PK  \u0026#34;ZORRO\u0026#34; //币名  ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: 700000, //最大一次性转出金额  \u0026#34;error\u0026#34;: null }   console\n  \u0026gt; exchange.getMaxAvailable(\u0026#34;0x0dbd9c0......9304201ea6\u0026#34;, \u0026#34;ZORRO\u0026#34;) 700000 ClearUsedFlag\r#\r\r  根据pk清除锁定标记\n  jsonrpc\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;exchange_clearUsedFlag\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0x0dbd9c0......9304201ea6\u0026#34; //账户的PK  ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: 3, //清除了3个UTXO的标记  \u0026#34;error\u0026#34;: null }   console\n  \u0026gt; exchange.clearUsedFlag(\u0026#34;0x0dbd9c0......9304201ea6\u0026#34;) 3 ClearUsedFlagForRoot\r#\r\r 根据UTXO的Root清除锁定标记    jsonrpc\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;exchange_clearUsedFlagForRoot\u0026#34;, \u0026#34;params\u0026#34;: [ [ \u0026#34;0x13ca7a0......75a3706b0\u0026#34;, //UTXO 的root  \u0026#34;0x244ae92......976fa00bc\u0026#34; ] ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: 2, \u0026#34;error\u0026#34;: null }   console\n  \u0026gt; exchange.clearUsedFlagForRoot([\u0026#34;0x0dbd9c0......9304201ea6\u0026#34;]) null 建议对接方案\r#\r\r 账户管理\r#\r\r 账户生成  通过离线客户端生成  随机生成一个32bytes的seed，安全保存。 调用js-zorro-client的account对象生成TK、PK  建议采用更加安全SuperZK2.0协议创建账户。     通过zro生成  在zro控制台调用personal.newAccount生成新账户 通过personal.exportRawKey导出seed，安全保存。  也可以保存对应的 keystore 文件   通过zorro.getTk获取账户TK。 通过zorro.accounts获取账户PK     账户导入  通过zro的控制台调用personal.importTk导入TK 通过日志监测exchange服务分析情况。    充值监测\r#\r\r 调用exchange.GetRecords根据块号不断同步PK新的充值记录。  注意ZORRO是隐私公链，签名交易时对引用的 UTXO 需要给出证明，如果交易引用的UTXO较多，交易签名时间会非常长。因此需要在日常对充值的UTXO进行合并，这样在提现的时候才会让用户有好的体验。 ZORRO提供离线和非离线签名合并UTXO交易的生成方法。  离线签名 GenMergeTx 非离线签名 Merge      提现\r#\r\r 构造preTxParam对象(参考GenTx的输入) 离线签名方式  调用GenTx获取txParam对象。 调用js-zorro-client的txsign方法签名 获取签名结果tx   在线签名方式  解锁zro的account 调用GenTxWithSign，生成签名后的交易tx   保存tx的hash值 调用CommitTx将tx提交到全节点 调用zorro.getTransactionReceipt扫描交易完成的情况 由于UTXO不能重复使用，并且genTx会锁定这次使用的UTXO，因此生成交易的时候建议  通过exchange.getMaxAvailable获取本次最大能发送的金额数。  需要对utxo进行merge确保当前能发送的金额较大。   每次生成完交易exchange.getMaxAvailable获取的值会发生变化，代表下一次可发送的金额。  循环调用exchange.getMaxAvailable和exchange.genTx|genTxWithSign直到exhange.getMaxAvailable为0。 发送完交易后等待新的UTXO生成。   如果有交易失败，除了重复提交交易外，可以通过exchange.ClearUsedFlag清除对这些UTXO的锁定。    自动UTXO合并\r#\r\r  如果是在线签名的方式，可以采用\n exchange的自动合并功能。  启动zro的时候加上--autoMerge参数。 当 pk 下的账户会定时进行自动的UTXO的合并。   在控制台调用exchange.Merge方法手动合并。    离线签名方向可以用exchange.genMergeTx构造合并交易。\n 然后进行离线签名后发送该交易。    "});index.add({'id':4,'href':'/docs/introduction/operate-in-console/','title':"控制台操作",'content':"控制台基础操作\r#\r\r 本机环境\r#\r\rubuntu16.04 / go1.13.11\n1. 启动控制台\r#\r\r zro --exchange --mineMode --stake --rpc --rpcaddr=\u0026#34;0.0.0.0\u0026#34; --dashboard --vmodule=dashboard=5 --rpcvhosts=\u0026#34;*\u0026#34; --rpccorsdomain=\u0026#34;*\u0026#34; --rpcapi=\u0026#34;exchange,zorro,net,stake\u0026#34; --exchangeValueStr zro attach 2. 账户管理\r#\r\r 创建账户指令\r#\r\r\u0026gt; personal.newAccount(\u0026#34;[PASSWORD]\u0026#34;) ... \u0026#34;[PK]\u0026#34; 其中 [PASSWORD] 是这个账户的密码，因为Zro不会直接存储用户的私钥，当5分钟没有任何操作，账户会被锁定，这时要用该账户进行转账，则需要用此密码对账户解锁。创建用户指令会返回该用户公钥。这个公钥可以作为转账地址。\n查看所有公钥\r#\r\r\u0026gt; zorro.accounts ... [\u0026#34;[PK0]\u0026#34;,\u0026#34;[PK1]\u0026#34;,...,\u0026#34;[PKn]\u0026#34;] 这个属性返回当前钱包中所有账户的公钥。\n解锁账户\r#\r\r\u0026gt; personal.unlockAccount(\u0026#34;[PK]\u0026#34;,\u0026#34;[PASSWORD]\u0026#34;) 其中[PK]是该用户公钥\n获取账户资产余额\r#\r\r\u0026gt; zorro.getBalance(\u0026#34;[PK]\u0026#34;) ... {tkn:{...},tkt:{...}} 其中tkn按分类显示账户所有Token余额，tkt按分类显示账户所有持有的Ticket。\n3. 挖矿\r#\r\r 启动挖矿\r#\r\r\u0026gt; miner.start() 停止挖矿\r#\r\r\u0026gt; miner.stop() 控制台休眠\r#\r\r\u0026gt; admin.sleepBlocks(num) 参数num是需要休眠的区块数，这个方法一定要在挖矿开启的情况下调用，否则将一直阻塞系统。 需要说明的是，挖矿所获得的奖励，默认条件下，会进入zorro.accounts的第0个账户的公钥生成的暂存地址(PKr) 中。\n4. 生成交易\r#\r\r 当accounts[0]中已经有挖矿所得的奖励的时候，既可以转账给其他账户。\n转账指令\r#\r\rzorro.sendTransaction({ from:\u0026#34;[SRC_PK]\u0026#34;, to:\u0026#34;[TARGET_PK]\u0026#34;, value:[NUM_OF_TA] }) ... \u0026#34;[TX_ID]\u0026#34; 其中[SRC_PK]是资金发出方公钥，[TARGET_PK]是资金接受方公钥，[NUM_OF_TA]是最小单位的金额，zorro的最小单位是TA，换算单位是 1 zorro = 10^18 TA。返回值[TX_ID]是生成交易的ID。\n交易生成之后，将同步给当前网络的其他节点，等待打包进区块中。在打包进区块之后，可以用下面的指令查询交易的详情。\n5. 获取交易详情\r#\r\r \u0026gt; zorro.getTransaction(\u0026#34;[TX_ID]\u0026#34;) ...[TX_DETAIL] 其中[TX_DETAIL]主要格式于下：\n{ from: \u0026#34;[SENDER PKr]\u0026#34;, stx: { Desc_Z_Ins: [{ Anchor: \u0026#34;[MERKLE AUTH ROOT]\u0026#34;, AssetCM: \u0026#34;[ASSET COMMITMENT]\u0026#34;, Nil: \u0026#34;[NULLIFIER ID]\u0026#34;, Trace: \u0026#34;[TRACE ID]\u0026#34; Proof: \u0026#34;[ZKP PROOF]\u0026#34; }], Desc_Z_Outs: [{ AssetCM: \u0026#34;[ASSET COMMITMENT]\u0026#34;, OutCM: \u0026#34;[OUTPUT COMMITMENT]\u0026#34;, PKr: \u0026#34;[RECIVER PKr]\u0026#34;, Proof: \u0026#34;[ZKP PROOF]\u0026#34; }], } } "});index.add({'id':5,'href':'/docs/course/','title':"教程",'content':""});index.add({'id':6,'href':'/docs/course/flight-interface/','title':"Flight接口说明",'content':"Flight Interface (FI) 接口说明\r#\r\r FI接口是SI的升级版，支持jsonrpc和console调用，并支持以下特点：\n zro不维护任何秘钥 提供离线签名方案 用户自主管理UTXO 分为离线接口(local)和在线接口(flight)  对接方案\r#\r\r 账户方案(离线)  在线下生成随机的32byte的seed (可以通过local_genSeed接口生成) 通过local_seed2Sk生成一个私钥sk离线保存。 通过local_sk2Tk生成一个跟踪秘钥 TK提供给在线部分系统。 通过local_tk2Pk生成一个公钥PK，提供给在线部分系统。 通过local_pk2Pkr以及随机数，为每一个用户绑定一个收款码PKr。   充值检测方案(在线)  不断迭代的调用flight_getBlocksInfo获取区块信息 判断block.Outs[i].State.OS.Out_O.Addr或者block.Outs[i].State.OS.Out_Z.PKr是否属于绑定用户。  如果属于绑定用户做下面几个事情  将block.Outs[i]以及跟踪秘钥TK作为参数调用local_decOut解出明文的UTXO数据 从解出的UTXO数据获取作废码列表Nils 将UTXO和Nils关联保存 将UTXO的资产数据入账     判断作废码block.Nils是否已经存在于之前保存的UTXO表中，如果存在，表明这个UTXO已经被用掉。   发送交易（在线和离线）  选择需要转账的UTXO以及相关转账信息构造的参数调用flight_genTxParam，生成txParam。 以txParam和私钥sk为参数调用离线签名方法local_signTxWithSk，生成待广播tx，并记录txhash。 记录local_signTxWithSk的结果中的keys。 以tx为参数调用flight_commitTx广播到全网。 不断的以txhash为参数调用flight_getTxReceipt,获取到打包块号。 确认32个块之后，还能从flight_getTxReceipt获取到数据则为成功交易。 遇到纠纷的时候，可以拿出keys，调用local_confirmOutZ来解出明文数据。    Local 接口\r#\r\rlocal 接口是离线性质的jsonrpc接口，虽然需要启动zro程序，但是除了rpc服务，zro不需要对外连接和同步数据。因此可以采用下面的参数启动zro服务。\n./zro --offline --mineMode --datadir ~/zroData --nodiscover --rpc --rpcport 8545 --rpcapi local,zorro --rpcaddr 127.0.0.1 --rpccorsdomain \u0026#34;*\u0026#34; --exchangeValueStr 账户管理\r#\r\r  随机生成seed\nseed需离线保存\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;local_genSeed\u0026#34;, \u0026#34;params\u0026#34;: [] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: \u0026#34;0xc0bdec98290c5a2895e357a6f96f4f7f98b6750d37e77971a055579e7246c403\u0026#34; //随机生成的seed，32byte的hex编码。  \u0026#34;error\u0026#34;: null }  go语言  seed:=c_type.RandUint256()   由seed生成sk\n私钥需离线使用\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;local_seed2Sk\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0xc0bdec98290c....79e7246c403\u0026#34;, //种子 seed  1 //SuperZK版本，1: 1.0 2: 2.0, 不填默认是 1  ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: \u0026#34;0x1657f2f6f8a743......595f96be89b4f03\u0026#34; //私钥 sk，64byte的hex编码。  \u0026#34;error\u0026#34;: null }  go语言  sk:=superzk.Seed2Sk( \u0026amp;seed, 1 //superzk协议版本 1:1.0 2:2.0 )   由sk生成tk\n跟踪秘钥TK无法对交易进行签名，因此可以在线使用。\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;local_sk2Tk\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0x1657f2f6f8....95f96be89b4f03\u0026#34; //私钥 sk  ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: \u0026#34;tu1nEPYcBwBZm......r5Y1cXNAs8Ht4z\u0026#34; //跟踪秘钥 tk，64byte 的 base58 编码。  \u0026#34;error\u0026#34;: null }  Go语言  tk:=superzk.Sk2Tk(\u0026amp;sk)   由tk生成PK\nPK是公钥，因此可以在线使用。\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;local_tk2Pk\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;tu1nEPYcBwBZ...1cXNAs8Ht4z\u0026#34; //跟踪秘钥 TK, 可以是 hex 或 base58 编码。  ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: \u0026#34;tu1nEPYcBwBZm......cZojp6obBD87N\u0026#34; //公钥 PK，64byte 的 base58 编码。  \u0026#34;error\u0026#34;: null }  Go语言  pk:=superzk.Tk2Pk(\u0026amp;tk)   由PK生成PKr\nPKr是收款码，可以在线使用，用来标识用户。\n request  { \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;local_pk2Pkr\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;tu1nEPYcBwBZ......cZojp6obBD87N\u0026#34;, //公钥 PK, 可以是 hex 或 base58 编码  \u0026#34;0xd7a8cc1c7a1d09575950ca8004e3409ab7a6505b39a8e29783338e5016d8e7d1\u0026#34; //32 byte 随机数  ] }  response  { \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: \u0026#34;26fUeqrEbq4qZU......MP9ehQLV5frg\u0026#34; //收款码 PKr， 96byte 的 base58 编码  \u0026#34;error\u0026#34;: null }  Go语言  pkr:=superzk.Pk2PKr(\u0026amp;pk)   UTXO解析\r#\r\r从flight_getBlocksInfo获取的区块信息中，可以获得新增的UTXO，UTXO是密文的，因此需要用跟踪秘钥TK进行解析，解析的方法local_decOut也是离线的。\n  request\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;local_decOut\u0026#34;, \u0026#34;params\u0026#34;: [ [{ //参数1：需要解析的UTXO列表，来自flight_getBlocksInfo  Root: \u0026#34;0x7b30cc8....510fbb122e\u0026#34;, State: { Num: 28, OS: { Index: 31, Out_O: { //明文的Out，与Out_Z只会存在一个  Addr: \u0026#34;0x7c02a05...ba6ac83a8\u0026#34;, Asset: {...}, Memo: \u0026#34;0x0000......0000\u0026#34; }, Out_Z: { //密文的Out  AssetCM: \u0026#34;0xa2a0f......745a9\u0026#34;, EInfo: \u0026#34;0x68a9e......b74ecfc493\u0026#34;, OutCM: \u0026#34;0xc90dc......90ff58f\u0026#34;, PKr: \u0026#34;0x9364f11......14406a3\u0026#34;, //收款码PKr的hex编码  Proof: \u0026#34;0x0341d67......f941b0d\u0026#34;, RPK: \u0026#34;0x6230d4......02b51c2\u0026#34; }, RootCM: \u0026#34;0xff107b......ebdae30a2\u0026#34; }, TxHash: \u0026#34;0x921b8......be44829\u0026#34; } }], \u0026#34;tu1nEPYcBwB......5Y1cXNAs8Ht4z\u0026#34; //参数2：该UTXO对应的TK  ] }   response\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: [{ Asset: { Tkn: { Currency: \u0026#34;0x00000......005345524f\u0026#34;, //币种名  Value: \u0026#34;1000000000000000000\u0026#34; //金额  }, Tkt: null //Ticket资产，交易所可以忽略  }, Memo: \u0026#34;0x0000000......0000000000\u0026#34;, //附带信息  Nils: [ //该UTXO的作废码  \u0026#34;0x5f2324......dda85393\u0026#34;, //只要在getBlocksInfo时碰到，该  \u0026#34;0x661f10......90a6a720\u0026#34; //UTXO即被作废  ] }], \u0026#34;error\u0026#34;: null }   下面是Go语言版的UTXO解析\nimport \u0026#39;github.com/ZorroChain/zorro/zero/txtool/flight\u0026#39; import \u0026#39;github.com/ZorroChain/zorro/zero/txtool\u0026#39; import \u0026#39;github.com/ZorroChain/zorro/czk/cpt\u0026#39; //--------- outs_str := \u0026#39;[{Root:\u0026#34;0x7b30cc8....510fbb122e\u0026#34;,....,TxHash:\u0026#34;0x921b8......be44829\u0026#34;}}]\u0026#39; tk_str := \u0026#39;0xfd1b401d2bbfa09fba577b398b09b5ea075bd8f37773095c6e62271a4b080977\u0026#39; //--------- cpt.ZeroInit_OnlyInOuts() //初始化 //--------- var outs []txtool.Out json.Unmarshal([]byte(outs_str),\u0026amp;outs) //--------- bs, _ := hexutil.Decode(tk_str) tk := keys.Uint512{} copy(tk[:], bs) //--------- douts,_=flight.DecOut(\u0026amp;tk,outs) 离线签名\r#\r\r在调用flight_genTxParam组装交易签名参数之后，可以传入私钥sk调用离线签名的方法local_signTxWithSk生成最终交易。生成最终交易之后，可以调用flight_commitTx，广播到全网。\n  request\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;local_signTxWithSk\u0026#34;, \u0026#34;params\u0026#34;: [ { // flight_genTxParam 的结果 txParam  \u0026#34;Cmds\u0026#34;: {}, \u0026#34;Fee\u0026#34;: {}, \u0026#34;From\u0026#34;: {}, \u0026#34;Gas\u0026#34;: 25000, \u0026#34;GasPrice\u0026#34;: 1000000000, \u0026#34;Ins\u0026#34;: [{}], \u0026#34;Outs\u0026#34;: [{},{}] }, \u0026#34;0x1657f2f6......f96be89b4f03\u0026#34; //私钥SK  ] }   response\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { //最终交易，可以通过flight_commitTx广播到全网  \u0026#34;Gas\u0026#34;: \u0026#34;0x61a8\u0026#34;, \u0026#34;GasPrice\u0026#34;: \u0026#34;0x3b9aca00\u0026#34;, \u0026#34;Hash\u0026#34;: \u0026#34;0x813f69b7d60fe694ddfd6bec36e2adcba773a4518ee02354bd8f2f339f004a2e\u0026#34;, \u0026#34;Keys\u0026#34;: [ //密文UTXO解析秘钥，不会提交到链上，可以保存作为确认证据。  \u0026#34;0x8e27d9fd65a178569b852cf71e476073b68c2f241074bbd7be712f145b84ee32\u0026#34;, \u0026#34;0x6d83ce881db4fd68876c9a84f354124a01f94d53e702facb4db8071bc6ae146f\u0026#34; ], \u0026#34;Bases\u0026#34;: [ //密文In解析秘钥，不会提交到链上，可以用flight_trace2Root提取Root。  \u0026#34;0x0000000000000000000000000000000000000000000000000000000000000000\u0026#34;\u0026#34; ], \u0026#34;Tx\u0026#34;: {} }, \u0026#34;error\u0026#34;: null }   也可以使用Go语言版的离线签名\nimport \u0026#39;github.com/ZorroChain/zorro/zero/txtool/flight\u0026#39; import \u0026#39;github.com/ZorroChain/zorro/zero/txtool\u0026#39; import \u0026#39;github.com/ZorroChain/zorro/czk/cpt\u0026#39; param_str:=\u0026#39;{\u0026#34;Gas\u0026#34;:25000,\u0026#34;GasPrice\u0026#34;:1000000000,\u0026#34;From\u0026#34;:{\u0026#34;SKr\u0026#34;:\u0026#34;0x0 .... }\u0026#39; //由全节点构造 sk_str:=\u0026#39;0xfd1b401d2bbfa09fba577b398b09b5ea075bd8f37773095c6e62271a4b080977\u0026#39; //------ cpt.ZeroInit_OnlyInOuts() //初始化 //------ var param txtool.GTxParam json.Unmarshal([]byte(param_str),\u0026amp;param) bs, _ := hexutil.Decode(sk_str) sk := keys.Uint512{} copy(sk[:], bs) //------可以自己组装SK--------- gtx, _:=flight.SignTx(sk,param) //------ tx, _ := json.Marshal(\u0026amp;gtx) 确认Out_Z\r#\r\r在交易签名的时候，会为每个Desc_Z中的Out生成一个Key，用这个Key可以通过接口local_confirmOutZ反解出这个的UTXO的明文。\n  request\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;local_confirmOutZ\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0x8e27d9fd65a17....7be712f145b84ee32\u0026#34;, //Key 解密秘钥，签名的时候返回出来。  { //Out_Z的内容  AssetCM: \u0026#34;0xb5c26....7bcdaf0425\u0026#34;, EInfo: \u0026#34;0x589fa119....741e562c1\u0026#34;, OutCM: \u0026#34;0xb1908....3e48c14\u0026#34;, PKr: \u0026#34;0x1da430a....27b0126\u0026#34;, Proof: \u0026#34;0x03eed61....b24ad9b2a\u0026#34;, RPK: \u0026#34;0xc80da39....3263c2\u0026#34; } ] }   response\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { Asset: { Tkn: { Currency: \u0026#34;0x000000000....0000005345524f\u0026#34;, Value: \u0026#34;1000\u0026#34; }, Tkt: null }, Memo: \u0026#34;0x0000000....00000000\u0026#34;, Nils: null }, \u0026#34;error\u0026#34;: null }     Go语言\ndec_out,err:=flight.ConfirmOutZ(\u0026amp;key,\u0026amp;outz)   确认Out_C\r#\r\r在交易签名的时候，会为每个Tx1中的Out_C生成一个Key，用这个Key可以通过接口local_confirmOutC反解出这个的UTXO的明文。\n  request\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;local_confirmOutC\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0x8e27d9fd65a17....7be712f145b84ee32\u0026#34;, //Key 解密秘钥，签名的时候返回出来。  { //Out_C的内容  AssetCM: \u0026#34;0xb5c26....7bcdaf0425\u0026#34;, EInfo: \u0026#34;0x589fa119....741e562c1\u0026#34;, PKr: \u0026#34;0x1da430a....27b0126\u0026#34;, Proof: \u0026#34;0x03eed61....b24ad9b2a\u0026#34;, RPK: \u0026#34;0xc80da39....3263c2\u0026#34; } ] }   response\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { Asset: { Tkn: { Currency: \u0026#34;0x000000000....0000005345524f\u0026#34;, Value: \u0026#34;1000\u0026#34; }, Tkt: null }, Memo: \u0026#34;0x0000000....00000000\u0026#34;, Nils: null }, \u0026#34;error\u0026#34;: null }     Go语言\ndec_out,err:=flight.ConfirmOutC(\u0026amp;key,\u0026amp;outc)   币名接口\r#\r\r币种Id是一个32byte的数组，将所有前面的\\0去掉之后可以转换为字符串。离线方法也提供了方便的互相转换的方法。\n  币名转币种Id\n  request\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;local_currencyToId\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;ZORRO\u0026#34; //币名字符串  ] }   response\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: \u0026#34;0x00000000....000005345524f\u0026#34;, //币种Id  \u0026#34;error\u0026#34;: null }   Go语言\ncurrency_id:=flight.CurrencyToId(currency_str)     币种Id转币名\n  request\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;local_idToCurrency\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0x00000000....000005345524f\u0026#34; //币种Id  ] }   response\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: \u0026#34;ZORRO\u0026#34;, //币名  \u0026#34;error\u0026#34;: null }   Go语言\ncurrency_str:=flight.IdToCurrency(currency_id)     Flight 接口\r#\r\r启动flight接口的zro需要同步最新的区块，提供的是在线功能。\n启动方式是：\n./zro --mineMode --datadir ~/zroData --port 53717 --rpc --rpcport 8545 --rpcapi flight,zorro --rpcaddr 127.0.0.1 --rpccorsdomain \u0026#34;*\u0026#34; --keystore ~/keystore --confirmedBlock 32 --rpcwritetimeout 1800 --exchangeValueStr 扫描区块\r#\r\r扫描区块可以获得区块中的新增UTXO和UTXO作废信息，但不管明文还是密文的UTXO都需要调用local_decOut解密才能获取更多的细节。\n  request\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;flight_getBlocksInfo\u0026#34;, \u0026#34;params\u0026#34;: [ 15, //起始区块高度  1 //获取后续多少区块  ] }   response\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: [{ //高度为15的区块对象  \u0026#34;Hash\u0026#34;: \u0026#34;0x33e2cb9.....42e836e3b6b5\u0026#34;, //区块hash  \u0026#34;Nils\u0026#34;: [ //该区块作废UTXO的作废码列表  \u0026#34;0x020d0....fc504a5\u0026#34;, \u0026#34;0x09f76....fe482a6\u0026#34;, \u0026#34;0xd2d8ff3....c5b4da6\u0026#34;, \u0026#34;0x51991f8....e4380a\u0026#34; ], \u0026#34;Num\u0026#34;: \u0026#34;0xf\u0026#34;, //本区块高度  \u0026#34;Outs\u0026#34;: [ //该区块新生成的UTXO列表  { //第1个UTXO  \u0026#34;Root\u0026#34;: \u0026#34;0x3f89df0c....300e3572d\u0026#34;, //该UTXO的Root  \u0026#34;State\u0026#34;: { \u0026#34;Num\u0026#34;: 15, \u0026#34;OS\u0026#34;: { \u0026#34;Index\u0026#34;: 15, \u0026#34;Out_O\u0026#34;: null, \u0026#34;Out_Z\u0026#34;: { //本UTXO是匿名的  \u0026#34;AssetCM\u0026#34;: \u0026#34;0x3defeb....fbe1ec80\u0026#34;, \u0026#34;EInfo\u0026#34;: \u0026#34;0x218271e....190115c0\u0026#34;, \u0026#34;OutCM\u0026#34;: \u0026#34;0x2920....ad5faa5\u0026#34;, \u0026#34;PKr\u0026#34;: \u0026#34;0xe1f....09b23\u0026#34;, //UTXO指向的收款码 PKr  \u0026#34;Proof\u0026#34;: \u0026#34;0x03d8b7e....5c88c2e06\u0026#34;, \u0026#34;RPK\u0026#34;: \u0026#34;0x44231e....96841\u0026#34; }, \u0026#34;Out_P\u0026#34;: null, \u0026#34;Out_C\u0026#34;: null, }, \u0026#34;TxHash\u0026#34;: \u0026#34;0x482a2....bd0a5c2\u0026#34; } }, { //第2个UTXO  \u0026#34;Root\u0026#34;: \u0026#34;0x8d98fe0....fe5bc71f\u0026#34;, \u0026#34;State\u0026#34;: { \u0026#34;Num\u0026#34;: 15, \u0026#34;OS\u0026#34;: { \u0026#34;Index\u0026#34;: 16, \u0026#34;Out_O\u0026#34;: { //本UTXO是明文的  \u0026#34;Addr\u0026#34;: \u0026#34;0x7c02a0....ba6ac83a8\u0026#34;, //UTXO指向的收款码 PKr  \u0026#34;Asset\u0026#34;: { \u0026#34;Tkn\u0026#34;: { \u0026#34;Currency\u0026#34;: \u0026#34;0x00000000....000005345524f\u0026#34;, \u0026#34;Value\u0026#34;: \u0026#34;1000025000000000000\u0026#34; }, \u0026#34;Tkt\u0026#34;: null }, \u0026#34;Memo\u0026#34;: \u0026#34;0x0000000....00000000\u0026#34; }, \u0026#34;Out_Z\u0026#34;: null }, \u0026#34;TxHash\u0026#34;: \u0026#34;0x0000000....00000001\u0026#34; } } ], \u0026#34;Pkgs\u0026#34;: null //Package 资产，交易所可以忽略  }], \u0026#34;error\u0026#34;: null }   获取区块额外信息\r#\r\r本接口可以获取最新的或指定区块的额外信息。\n  request\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;flight_getBlockByNumber\u0026#34;, \u0026#34;params\u0026#34;: [ 15 //区块高度，为空则是获取当前最新区块  ] }   response\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { BlockHash: \u0026#34;0x33e2cb....e3b6b5\u0026#34;, //块Hash  BlockNumber: 15, //块号  Timestamp: 1565153901, //时间戳  TxHashes: [\u0026#34;0x482a2....1bd0a5c2\u0026#34;] //交易Hash列表  }, \u0026#34;error\u0026#34;: null }   获取某个UTXO详情\r#\r\r通过UTXO的root获取UTXO详情\n  request\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;flight_getOut\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0x0x7b30cc8....510fbb122e\u0026#34; //某个UTXO的Root  ] }   response\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { //UTXO 详情  Root: \u0026#34;0x7b30cc8....510fbb122e\u0026#34;, State: { Num: 28, OS: { //下面的 Out_O/Out_Z/Out_P/Out_C 只会存在一个  Index: 31, Out_O: { //SUPERZK1.0 明文的Out  Addr: \u0026#34;0x7c02a05...ba6ac83a8\u0026#34;, //收款码PKr的hex编码  Asset: {...}, Memo: \u0026#34;0x0000......0000\u0026#34; }, Out_Z: { //SUPERZK1.0 密文的Out  AssetCM: \u0026#34;0xa2a0f......745a9\u0026#34;, EInfo: \u0026#34;0x68a9e......b74ecfc493\u0026#34;, OutCM: \u0026#34;0xc90dc......90ff58f\u0026#34;, PKr: \u0026#34;0x9364f11......14406a3\u0026#34;, //收款码PKr的hex编码  Proof: \u0026#34;0x0341d67......f941b0d\u0026#34;, RPK: \u0026#34;0x6230d4......02b51c2\u0026#34; }, Out_P: { //SUPERZK2.0 明文Out  Asset: {...}, Memo: \u0026#34;0x00000....000000\u0026#34;, PKr: \u0026#34;0x77305....6bce36e\u0026#34; //收款码PKr的hex编码  }, Out_C: { //SUPERZK2.0 密文Out  AssetCM: \u0026#34;0xd3be8490....12904aa09\u0026#34;, EInfo: \u0026#34;0xd42e33....b46e1cd3\u0026#34;, PKr: \u0026#34;0xcc0c3b71....d7fcbd3\u0026#34;, //收款码PKr的hex编码  Proof: \u0026#34;0x02a04a89....ede4dca72f\u0026#34;, RPK: \u0026#34;0x855ba....352e88021\u0026#34; }, RootCM: \u0026#34;0xff107b......ebdae30a2\u0026#34; }, TxHash: \u0026#34;0x921b8......be44829\u0026#34; //交易Hash  } }, \u0026#34;error\u0026#34;: null }   获取原始交易详情\r#\r\r通过交易hash获取原始交易报文，即签名后的交易结构，这个交易结构不可作为最后入账的依据。\n  request\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;flight_getTx\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0x482a2f......1bd0a5c2\u0026#34; //某个交易的hash  ] }   response\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { //原始交易信息  \u0026#34;Gas\u0026#34;: \u0026#34;0x15f90\u0026#34;, \u0026#34;GasPrice\u0026#34;: \u0026#34;0x3b9aca00\u0026#34;, \u0026#34;Hash\u0026#34;: \u0026#34;0x482a2......d0a5c2\u0026#34;, \u0026#34;Tx\u0026#34;: { \u0026#34;Bcr\u0026#34;: \u0026#34;0x3334c5......9ffe532e\u0026#34;, \u0026#34;Bsign\u0026#34;: \u0026#34;0xa9045b3......03d3c4503\u0026#34;, \u0026#34;Desc_Cmd\u0026#34;: { //执行命令描述，交易所可忽略  \u0026#34;BuyShare\u0026#34;: null, \u0026#34;ClosePool\u0026#34;: null, \u0026#34;Contract\u0026#34;: null, \u0026#34;RegistPool\u0026#34;: null }, \u0026#34;Desc_O\u0026#34;: { \u0026#34;Ins\u0026#34;: [{ //明文的输入  \u0026#34;Nil\u0026#34;: \u0026#34;0x020d0......c504a5\u0026#34;, \u0026#34;Root\u0026#34;: \u0026#34;0x09f765......5fe482a6\u0026#34;, \u0026#34;Sign\u0026#34;: \u0026#34;0xcde0ef......c05e1b3b02\u0026#34; }], \u0026#34;Outs\u0026#34;: [] //明文输出，只用于智能合约，交易所忽略  }, \u0026#34;Desc_Pkg\u0026#34;: { \u0026#34;Close\u0026#34;: null, \u0026#34;Create\u0026#34;: null, \u0026#34;Transfer\u0026#34;: null }, \u0026#34;Desc_Z\u0026#34;: { \u0026#34;Ins\u0026#34;: [], //密文输入  \u0026#34;Outs\u0026#34;: [{ //密文输出  \u0026#34;AssetCM\u0026#34;: \u0026#34;0x3defeb7......afbe1ec80\u0026#34;, \u0026#34;EInfo\u0026#34;: \u0026#34;0x218271ed71......4190115c0\u0026#34;, \u0026#34;OutCM\u0026#34;: \u0026#34;0x29201d......1ad5faa5\u0026#34;, \u0026#34;PKr\u0026#34;: \u0026#34;0xe1f915......f09b23\u0026#34;, \u0026#34;Proof\u0026#34;: \u0026#34;0x03d8b......8c2e06\u0026#34;, \u0026#34;RPK\u0026#34;: \u0026#34;0x44231......f196841\u0026#34; }] }, \u0026#34;Ehash\u0026#34;: \u0026#34;0xe0624......fb4b00c\u0026#34;, \u0026#34;Fee\u0026#34;: { //手续费  \u0026#34;Currency\u0026#34;: \u0026#34;0x0000000......00005345524f\u0026#34;, //币种，可以用local_hexToCurrency翻译  \u0026#34;Value\u0026#34;: \u0026#34;90000000000000\u0026#34; //金额  }, \u0026#34;From\u0026#34;: \u0026#34;0x3fb451......42be2a0\u0026#34;, //发送方收款码，也是多余gas退回的地址。  \u0026#34;Sign\u0026#34;: \u0026#34;0x5fdd91......d98405\u0026#34;， \u0026#34;Tx1\u0026#34;: { //SuperZK2.0 交易内容  \u0026#34;Ins_C\u0026#34;: [{...}], //密文输入  \u0026#34;Ins_P\u0026#34;: [], //明文输入  \u0026#34;Ins_P0\u0026#34;: [], //SuperZK1.0-2.0转换输入  \u0026#34;Outs_C\u0026#34;: [{...}], //密文输出  \u0026#34;Outs_P\u0026#34;: [{...}] //明文输出  } } }, \u0026#34;error\u0026#34;: null }   获取交易收据\r#\r\r获取交易的结果，如果请求成功，说明交易已经成功打包进区块。\n  request\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;flight_getTxReceipt\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0x482a2f......1bd0a5c2\u0026#34; //某个交易的hash  ] }   response\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { BHash: \u0026#34;0x33e2cb......e836e3b6b5\u0026#34;, //打包区块Hash  BNum: 15, //打包区块高度  Nils: [ //交易的作废码列表  \u0026#34;0x09f765a......d55fe482a6\u0026#34;, \u0026#34;0x51991f8e......6fe2dfe4380a\u0026#34; ], Outs: [ //交易生成的UTXO的Root列表  \u0026#34;0x3f89df0c......e14a300e3572d\u0026#34;, \u0026#34;0x3f9e217......94fdabde70a7\u0026#34;, \u0026#34;0x1d87a74a3......2d725144d6cd15\u0026#34; ], Pkgs: null, PoolId: null, ShareId: null, State: 1, //智能合约运行是否成功  TxHash: \u0026#34;0x482a2f219d......a11bd0a5c2\u0026#34; //交易Hash  }, \u0026#34;error\u0026#34;: null }   组装交易签名参数\r#\r\r对接人需要自己选择要使用的UTXO来组装交易，组装时需要在线提供跟踪秘钥TK，flight_genTxParam方法会获取当前区块见证，并自动产生找零的Out来配平交易的金额。输出的结果可以用local_signTxWithSk进行签名。\n  request\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;flight_genTxParam\u0026#34;, \u0026#34;params\u0026#34;: [{ //参数1：预组装交易结构  \u0026#34;From\u0026#34;: \u0026#34;0xb8d01......143099\u0026#34;, //找零收款码PKr，需要与TK配套。  \u0026#34;Gas\u0026#34;: 25000, //最大Gas消耗  \u0026#34;GasPrice\u0026#34;: 1000000000, //Gas价格，最小为1Gta  \u0026#34;Ins\u0026#34;: [\u0026#34;0x7b30c......0fbb122e\u0026#34;], //输入UTXO的Root列表，需要确保是TK下面的UTXO。  \u0026#34;Outs\u0026#34;: [{ //输出  \u0026#34;Asset\u0026#34;: { //资产对象  \u0026#34;Tkn\u0026#34;: { //Token对象（同质化通证）  \u0026#34;Currency\u0026#34;: \u0026#34;0x00000......005345524f\u0026#34;, //币种Id，去掉0之后就是ASCII字符串 \u0026#34;ZORRO\u0026#34;  \u0026#34;Value\u0026#34;: \u0026#34;500000000000000000\u0026#34; //币种金额  } }, \u0026#34;PKr\u0026#34;: \u0026#34;0x3b78d......4603daa\u0026#34; //输出的收款码PKr  }] }, \u0026#34;tu1nEPY......As8Ht4z\u0026#34; //参数2：跟踪秘钥TK  ] }   response\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: { \u0026#34;Cmds\u0026#34;: { //交易命令  \u0026#34;BuyShare\u0026#34;: null, \u0026#34;ClosePool\u0026#34;: null, \u0026#34;Contract\u0026#34;: null, \u0026#34;PkgClose\u0026#34;: null, \u0026#34;PkgCreate\u0026#34;: null, \u0026#34;PkgTransfer\u0026#34;: null, \u0026#34;RegistPool\u0026#34;: null }, \u0026#34;Fee\u0026#34;: { //交易费用  \u0026#34;Currency\u0026#34;: \u0026#34;0x0000000......0005345524f\u0026#34;, \u0026#34;Value\u0026#34;: \u0026#34;25000000000000\u0026#34; }, \u0026#34;From\u0026#34;: { //Gas找回收款码PKr  \u0026#34;PKr\u0026#34;: \u0026#34;0xb8d018f2......58143099\u0026#34;, \u0026#34;SKr\u0026#34;: \u0026#34;0x00000......00000\u0026#34; }, \u0026#34;Gas\u0026#34;: 25000, //最大gas消耗  \u0026#34;GasPrice\u0026#34;: 100000000, //Gas价格  \u0026#34;Ins\u0026#34;: [{ //输入列表  \u0026#34;Out\u0026#34;: { \u0026#34;Root\u0026#34;: \u0026#34;0x7b30cc81......10fbb122e\u0026#34;, \u0026#34;State\u0026#34;: { \u0026#34;Num\u0026#34;: 28, \u0026#34;OS\u0026#34;: { \u0026#34;Index\u0026#34;: 31, \u0026#34;OutCM\u0026#34;: null, \u0026#34;Out_O\u0026#34;: null, \u0026#34;Out_Z\u0026#34;: { \u0026#34;AssetCM\u0026#34;: \u0026#34;0xa2a0f0......03745a9\u0026#34;, \u0026#34;EInfo\u0026#34;: \u0026#34;0x68a9ed......cfc493\u0026#34;, \u0026#34;OutCM\u0026#34;: \u0026#34;0xc90dc......0ff58f\u0026#34;, \u0026#34;PKr\u0026#34;: \u0026#34;0x9364f......4406a3\u0026#34;, \u0026#34;Proof\u0026#34;: \u0026#34;0x0341d6......57f941b0d\u0026#34;, \u0026#34;RPK\u0026#34;: \u0026#34;0x6230d427......02b51c2\u0026#34; }, \u0026#34;RootCM\u0026#34;: \u0026#34;0xff107b......dae30a2\u0026#34; }, \u0026#34;TxHash\u0026#34;: \u0026#34;0x921b8......e44829\u0026#34; } }, \u0026#34;SKr\u0026#34;: \u0026#34;0x0000000......000000\u0026#34;, \u0026#34;Witness\u0026#34;: { \u0026#34;Anchor\u0026#34;: \u0026#34;0xde09cc......463503\u0026#34;, \u0026#34;Paths\u0026#34;: [ \u0026#34;0x1777ebb......b3cf9c2c\u0026#34;, ...... \u0026#34;0x3edc6......be382\u0026#34; ], \u0026#34;Pos\u0026#34;: \u0026#34;0x1f\u0026#34; } }], \u0026#34;Outs\u0026#34;: [{ //输出列表  \u0026#34;Asset\u0026#34;: { \u0026#34;Tkn\u0026#34;: { \u0026#34;Currency\u0026#34;: \u0026#34;0x00000000......000005345524f\u0026#34;, \u0026#34;Value\u0026#34;: \u0026#34;500000000000000000\u0026#34; }, \u0026#34;Tkt\u0026#34;: null }, \u0026#34;Memo\u0026#34;: \u0026#34;0x00000000......0000000000\u0026#34;, \u0026#34;PKr\u0026#34;: \u0026#34;0x3b78dd......4603daa\u0026#34; }, { //自动配平的找零输出  \u0026#34;Asset\u0026#34;: { \u0026#34;Tkn\u0026#34;: { \u0026#34;Currency\u0026#34;: \u0026#34;0x0000000......00005345524f\u0026#34;, \u0026#34;Value\u0026#34;: \u0026#34;499975000000000000\u0026#34; }, \u0026#34;Tkt\u0026#34;: null }, \u0026#34;Memo\u0026#34;: \u0026#34;0x0000000......0000000\u0026#34;, \u0026#34;PKr\u0026#34;: \u0026#34;0xb8d018......143099\u0026#34; }] }, \u0026#34;error\u0026#34;: null }   广播交易\r#\r\r在调用local_signTxWithSk进行签名之后，输出的交易可以调用flight_commitTx广播到全网。\n  request\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;flight_commitTx\u0026#34;, \u0026#34;params\u0026#34;: [{ //local_signTxWithSk的输出  \u0026#34;Gas\u0026#34;: \u0026#34;0x61a8\u0026#34;, \u0026#34;GasPrice\u0026#34;: \u0026#34;0x3b9aca00\u0026#34;, \u0026#34;Hash\u0026#34;: \u0026#34;0x813f69b7d60fe694ddfd6bec36e2adcba773a4518ee02354bd8f2f339f004a2e\u0026#34;, \u0026#34;Tx\u0026#34;: {...} }] }   response\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: null, //成功返回null  \u0026#34;error\u0026#34;: null, }   通过 TK 和 Trace 提取对应的Root\r#\r\r在交易签名的时候，会为每个In_Z或者In_C中的In生成一个Base，通过Base、Trace/NIL、TK三个值用flight_trace2Root可以提取该In对应的UTXO的Root。\n  request\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;jsonrpc\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;flight_trace2Root\u0026#34;, \u0026#34;params\u0026#34;: [ \u0026#34;0xbb793767f......070f62f05\u0026#34;, //TK 跟踪秘钥  \u0026#34;0x0207f1a29......e7652eda1\u0026#34;, //Trace 原始Desc_Z.Ins 中的Trace字段  \u0026#34;0x000000000......000000000\u0026#34; //签名之后对应的Base值  ] }   response\n{ \u0026#34;id\u0026#34;: 0, \u0026#34;result\u0026#34;: \u0026#34;0x51182a6775......f07d1e49a095\u0026#34;, //Root值  \u0026#34;error\u0026#34;: null, }   "});index.add({'id':7,'href':'/docs/course/principle-of-anonymous-token/','title':"匿名Token发行原理",'content':"匿名Token发行原理\r#\r\r ZORRO是全球首个支持图灵完备智能合约的隐私区块链系统，既然是支持智能合约，当然不可能是简单的智能合约+匿名币。ZORRO深度整合了两者的优点：智能合约的开放性、隐私系统的封闭性。在这两种特性的支持下，ZORRO的智能合约具有非常令人兴奋的特性，可以做到一些神奇的事情。\n本文主要讲解ZORRO提供的 匿名 Token API 在智能合约的应用，并在开篇简要的介绍一下匿名Token的生成原理。\n一、UTXO和ACCOUNT\r#\r\r 了解区块链构成的读者应该都知道，区块链是一个分布式账本，每个账本包含多笔交易Tx，而每笔交易又包含有多个记录。账本最小的单位是记录，每一笔帐记录一个账户资产的流入或者流出。但从实际的实现方式看，根据资产流出记录方式的不同，区块链系统演化出两种不同的记账实现，我们分别称之为UTXO模式和ACCOUNT模式。这两种模式分别对应比特币和以太坊的模式。而ZORRO则采用更为复杂的混合模式。\n基于UTXO的交易\r#\r\r如上图，UTXO模式的记录有两种，对交易发起者来说就是Input和Output，这个Output在交易接受方看来就是未花费输出(UTXO)，直到交易接受者再发起一个交易，指定一个Input将这个UTXO作废掉。交易中的记录始终在链接各种输入和输出。在这种模式下，ACCOUNT作为一种状态摘要，不是必须的。\n例如在上图中，Alice之前收到过一个交易Tx 0，这笔交易有一个输出UTXO 0，UTXO 0中有V个ZORRO币，她的账户上可以记录 [+V ZORRO,BALANCE=V]。而之后她将这V个ZORRO币转给Bob，那么她生成一个交易Tx 1，这个交易有一个Input将UTXO 0作废掉，那么Alice的ACCOUNT就应该记录[-V ZORRO,BALANCE=0]。而对于Bob，他就增加了一个价值为V个ZORRO的UTXO 1，如果他的ACCOUNT之前的BALANCE是0，它账户上就可以记录[+V ZORRO,BALANCE=V]。\n这种模式有两个优点：\n UTXO模式每笔交易是相互独立的，这意味着只要能处理好双花的问题，一个账户下的交易都可以并行处理，能充分应用多核CPU的能力。 UTXO本质上来说就是基于历史的记录形式，既是过程，也是结果，因此在一些需要生成见证证明的应用场合下，具有非常大的优势。这也是为什么具有隐私特性的区块链系统基本都是UTXO模式的。  基于ACCOUNT的交易\r#\r\r之前UTXO模式说到了每个账户可以生成一个临时的ACCOUNT作为状态摘要，在UTXO模式中，这个账户是临时的，不是必须的。而ACCOUNT模式中，交易中的每个资产流入流出记录都引用ACCOUNT而不是UTXO，记录Input表示增加这个ACCOUNT的资产，而记录Output表示减少一个账户的资产。在这种模式下，ACCOUNT实体是必须的，没有这个ACCOUNT，所有的记录都没有了意义。\n跟上面一样，例如，Alice之前收到过一个交易Tx 0，这个交易有一个资产值为V个ZORRO的输出Output 0，她的ACCOUNT将增加V个ZORRO。这时她要给Bob转出V个ZORRO币，那么她发起一笔交易，交易的Input指向她的ACCOUNT，价值为V ZORRO币，Output 1指向Bob的ACCOUNT，价值也是V ZORRO币，那么这笔交易被系统处理的时候，将直接加减双方的ACCOUNT中的资产。在这种模式下，Alice并不能区分这个Input究竟是使用的Output 0输入的ZORRO币还是之前就已经存放在ACCOUNT的ZORRO币。\nACCOUNT模式也有两个优势\n ACCOUNT模式直接增减一个独立账户中的资产，只需一个记录就可以增减一个账户的任意数量的资产。因此，生成的记录大小比同样情况下UTXO生成的记录要小很多。 ACCOUNT模式本质上是基于状态的，Input和Output是过程，ACCOUNT是结果，因此它天然就容易将图灵机引进来，这也是为什么支持图灵完备智能合约的区块链系统多采用ACCOUNT模式的原因。  ZORRO的混合模式\r#\r\rZORRO将UTXO和ACCOUNT模式混合应用，在需要支持隐私保护的地方采用UTXO模式，在需要运行智能合约的地方采用ACCOUNT模式。ZORRO通过交易、共识、以及Pedersen Commitment算法，将这两种模式无缝的整合到一起，使智能合约能发挥令人惊讶的能力。\n 本文所提到的智能合约，在ZORRO的白皮书中，对应 链上运行智能合约 这个概念\n 二、匿名交易结构\r#\r\r 在BetaNet网络中，ZORRO的普通交易是强制匿名的。因为如果可以允许任意非匿名交易，那么想要使用匿名功能的用户的隐私安全在关联交易中将得不到保证。另外，如果想要公示自己的资产等信息，建议使用智能合约，有限度的公开部分信息。\n 在MainNet发布时，ZORRO通过选择隐私级别来获得隐私性和生成速度的平衡。\n 交易 Tx\r#\r\rZORRO的匿名交易Tx拥有一个匿名的输入集合Z ins，一个匿名输出集合Z outs，一个普通输出集合O outs，和一个名为From的暂存地址。Z ins完全是匿名的，让第三方观察者无法得知来源和内容，Z outs是完全匿名的UTXO，只有接收者能查看和使用它的内容，O outs携带的内容是非隐藏的，它指向的接受者有两种情况：一种是指向智能合约地址，一种是指向一个暂存地址。From代表着交易发送者，同样也是一个暂存地址。因此整个Tx无法让人确定真实的用户是谁，其中携带的资产等信息也最大程度被隐藏起来。\n输入 Z ins\r#\r\r在ZORRO交易的输入集合Z ins中，每个输入都是匿名的，包括来源UTXO的Id以及携带的资产信息。每个输入都通过采用零知识证明ZKP生成的Proof，指向一个被隐藏在巨大的UTXO序列中特定的某个UTXO，这个序列是ZORRO历史的一部分，所有的细节信息被Proof隐藏起来。验证者在不知道细节信息的情况下，通过Proof能确认这个输入是否合法。这种方式跟环签很像，不过我们的Proof自身的大小要比环签小很多，而且在零知识证明下，用来隐匿UTXO的集合的范围比环签也要大得多。\n两种不同的输出 outs\r#\r\rZORRO交易中包含的输出分为两种形式，零知识输出Z out和普通输出O out。\nZ out Z out指向的是暂存地址PKr，暂存地址只有接受者能解密出身份。由于每个暂存地址都不一样，所以，没有第三方能够识别Z out的指向。Z out还携带了资产的加密信息Encrypt Info，只有持有接受者私钥的人才能解密这些信息。而OutCM是输出承诺，只有交易的双方才能够复现OutCM的计算过程。OutCM在证明 “Z out被ins引用” 这一过程起到至关重要的作用。\nO out O out指向的PKr有两种形式，一种是由智能合约发起的，指向普通账户的暂存地址。另一种是由普通账户发起的，指向智能合约的地址。由于暂存地址的随机性，第三方无法得知接受者的身份，O out携带的资产信息是公开的。\n输入和输出的平衡 Balance\r#\r\rTx将ins、Z outs、O outs打包到一起，如何防止恶意攻击者篡改里面的数据并确保资产安全呢，我们通过引入perdesen commitment，它的同态加密特性使验证者在不知道信息细节的情况下，可以确认Balance一定是平衡的，即输入等于输出。\n另外，为了防止恶意攻击者对O outs的篡改，我们利用perdesen commitment的随机特性，以Balance的随机部分对Tx Hash进行签名。如此以来，各个输入输出都可以独立进行计算，然后通过B-Sign打包到一起。\n交易发送者 From\r#\r\r当交易的输出是指向智能合约时，智能合约有时根据编写的规则，需要将资源给输出到给定的账户。这时暂存地址From就是承接输出资源的地方。From在交易生成的时候就被确定，并且只使用一次，除了交易发送者外，其他人无法定位发送者的身份。\n三、发行匿名Token的原理\r#\r\r Token资产\r#\r\rToken又称之为“同质化通证”，是ZORRO系统内部承认的一种资产形式。相同种类的Token可以任意的分割和混合，具体来说就是所谓的“币”。ZORRO币作为ZORRO系统的第一个币种，本质上也是一种Token。对于Token资产，除了手续费规定只能以ZORRO币缴纳外，在ZORRO系统的内部是同一对待的，由共识确保其隐私和安全性。\n 与以太坊中的Token概念不同，以太坊中的Token只是智能合约内部记录的一个符号，而ETH才是以太坊内部真正运行的Token资产。\n 币名\r#\r\r每种Token都有一个币名，ZORRO系统初始化后，默认只有一个被注册的币名ZORRO。在智能合约发行匿名Token的时候，必须向ZORRO系统注册一个全局唯一的字符串作为该Token的币名。币名可以极大的提高你发行资产的可读性。\n匿名Token资产\r#\r\rZORRO的智能合约有一个非常强大的功能，那就是可以任意发行匿名Token。当然，前提是你需要一个从未注册过的币名。一旦匿名Token发行成功，智能合约可以将Token以普通交易的形式发送到某个普通账户的暂存地址PKr，这时这些被发送的Token将以UTXO的形式脱离智能合约账户，并且与ZORRO币一样，进入用户的个人账户中，从而被ZORRO的隐私机制所保护。\n ZORRO币的发行是由矿工实现的，过程与智能合约发行匿名Token的机制类似，是ZORRO内建的Token发行功能。\n "});index.add({'id':8,'href':'/docs/course/how-to-staking-using-gero/','title':"如何在ZORRO上进行Staking",'content':"如何在ZORRO上进行Staking\r#\r\r  本文主要为全节点后台程序使用者提供，界面钱包的使用者请静待后续说明文档。\nStaking 功能需要在 117600的高度之后才生效\n 进行Staking需要开启ZORRO的exchange服务，启动时可以加入--exchange --mineMode两个参数：\n./zro --exchange --mineMode --datadir ~/datadir 注意：加入这两个参数后，会对账户余额重新分析，将有一段时间（几个小时）无法看到正确的余额。\n如果需要通过jsonrpc接口调用staking的命令，可以通过加入—rpcapi stake参数开启。开启后jsonrpc的方法名可以跟其他的形式一致，比如stake.buyShare的方法名是stake_buyShare。\nStaking 过程简要描述\r#\r\r  POS 矿工可以在股份池里面购买投票的股份  股份设有股份池，无上限。 股份的价格根据股份池大小动态调整。 股份池大小 326592 以内股份价格的变化比较平衡。 股份池大小超过 326592 后股份价格急剧上升。   POW 矿工计算出区块 HASH 之后，将随机在股份池中选择 3 个股份，并广播选票信息。 POS 矿工收到属于自己的选票信息之后，立即广播自己签名后的投票信息。 POW 矿工在收到 POS 矿工的投票信息之后，将签名放入区块头部信息中。 如果正确的投票超过 2 个，POW 矿工将广播区块，完成出块过程。 POS 矿工可以选择 SOLO 投票或 StakingNode 代投票。 每个区块奖励分为 POW 奖励和 POS 奖励  POW 奖励和 POS 奖励的比例为 4 : 4 POW 奖励和 POS 奖励的大小随各自难度独立变化。   POS 奖励分为 Solo 投票和 StakingNode 代投票两种情况  Solo 奖励和代投票奖励的比例为 3 : 4   完成投票过程后，所涉及的奖励和本金会在最近的一个支付周期（大约1周）内退回。  Share 的生命周期\r#\r\r  用户选择一定的价格购买股份后，本金即进入锁定状态**(Lock)**，股份进入当前的股份池中 **(InPool)**。 POW矿工在出块时随机选择3份股份，被选中的股份进入待投票状态 (Lottery)  至少获得两个投票才能完成出块过程。   POS矿工在接收到待投票消息后，成功将投票信息广播给POW矿工完成出块，股份进入完成状态**(Votted)**  进入完成状态的股份会在一个支付周期(一周)内归还本金和奖励，同时释放股份。   当区块只有两份成功投票的情况下，另外一份股份则进入错失状态**(Missed)**。  作为惩罚，进入错失状态的股份将会在连续锁定3个月后释放本金。   在股份池中没有被成功选中的股份一个月后过期**(Expire)**  过期时会释放本金。    StakingNode的生命周期\r#\r\r  运营者通过锁定20万ZORRO币可以获得运营StakingNode 的权利。 StakingNode在运营一个月后，才能通过手工关闭，进入关闭状态 (Close)  关闭之后将不允许新的股份代投申请。 同时运营者有义务完成现在StakingNode中已有的股份。   StakingNode在同时满足下面两个条件下将归还本金进入结束状态**(Finish)**：  所有代投股份本金全部释放 进入关闭状态    SOLO Staking\r#\r\r 你拥有一个全节点程序(ZORRO)，并且拥有一定数量的 ZORRO 代币，既可进行SOLO，获取POS奖励部分比例为 3 的奖励。\nSOLO 的前提条件\r#\r\r 一个可以持续运行的全节点程序(ZORRO)，并且已经同步完成区块。 ZORRO链上账户中拥有一定数量的 ZORRO 代币。  步骤\r#\r\r1. 步骤概要\r#\r\r 确认拥有购买股份的ZORRO代币。  发放收益或者股份过期的时候本金也会一起退回   创建投票账户。 开启自动投票功能（解锁投票账户）。 在股份池中购买股份。 查看当前股份情况。 确认收益。   注意：一定要备份好账户密钥，普通用户可以拷贝keystore进行备份，也可以导出助记词：\n\u0026gt; personal.exportMnemonic(zorro.accounts[0]) export account mnemonic 5bEgN9YL......Xrpti4zeamkdD16C Passphrase: 1234 //密码 \u0026#34;casino crys ... ... en unaware route\u0026#34; 可以这样导入助记词：\n\u0026gt; personal.importMnemonic(\u0026#34;casino cry ... ... re route\u0026#34;,\u0026#34;1234\u0026#34;) //1234 是密码  2. 确认资产账户\r#\r\r为了安全，ZORRO 的资产账户和投票账户是分离的，本金和奖励只会由资产账户处理，我们现在确认资产账户。\n\u0026gt; zorro.accounts[0] \u0026#34;5bEgN9YLqC......4zeamkdD16C\u0026#34; //账户公钥PK \u0026gt; web3.fromTa(zorro.getBalance(zorro.accounts[0]).tkn.ZORRO) 10 //20 个ZORRO 3. 创建投票账户\r#\r\r投票账户里面不处理资产，只用来进行投票签名。\n\u0026gt; personal.newAccount(\u0026#34;1234\u0026#34;) \u0026#34;2tuxyM5uL4......Ce5xNPokr\u0026#34; \u0026gt; zorro.accounts[1] \u0026#34;2tuxyM5uL4......Ce5xNPokr\u0026#34; //账户公钥PK 投票账户需要永久解锁，以便于被抽中后可以快速的进行投票。\n\u0026gt; personal.unlockAccount(zorro.accounts[1],\u0026#34;1234\u0026#34;,0) 注意：SOLO Staking 需要确保全节点网络稳定，否则可能导致投票被 MISS\n4. 查看股份池状态\r#\r\r  跟staking有关的接口都在stake对象里面\n\u0026gt; stake { sharePoolSize: \u0026#34;0x0\u0026#34;, //股份池当前大小  sharePrice: \u0026#34;0x1bc16d674ec80000\u0026#34;, //当前股份价格  buyShare: function(), closeStakePool: function(), getShare: function(), getSharePoolSize: function(callback), getSharePrice: function(callback), modifyStakePoolFee: function(), modifyStakePoolVote: function(), myShare: function(), poolState: function(), registStakePool: function(), stakePools: function() }   查看当前股份池的情况\n\u0026gt; web3.fromTa(web3.toDecimal(stake.sharePrice)) \u0026#34;2\u0026#34; // 当前股份价各是 2 ZORRO \u0026gt; web3.toDecimal(stake.sharePoolSize) 0 // 当前股份池里面是 0 个股份   5. 认购股份\r#\r\r  估算能购买的股份数\n 因为股份价格随股份池的大小线性增加，所以需要先估算可购买的股份数。  \u0026gt; stake.estimateShares({ from:zorro.accounts[0], //资金账户  vote:zorro.accounts[1], //投票账户  value:web3.toTa(20) //可出的总金 }) { avPrice: \u0026#34;0x1bc6ab6c2dfe1734\u0026#34;, //平均股份价格  basePrice: \u0026#34;0x1bc16d674ec80000\u0026#34;, //基础股份价格  total: \u0026#34;0x9\u0026#34; //可购买数量 }   认购，from 资金账户，vote 是投票账户，value是本次认购资金\n 为了使购买股份分散，每次最多购买1000分股份。  \u0026gt; stake.buyShare({from:zorro.accounts[0],vote:zorro.accounts[1],value:web3.toTa(20)}) \u0026#34;0xac137baf4cd195....17c1fcb3edae4d25\u0026#34; \u0026gt; zorro.getTransactionReceipt(\u0026#34;0xac137baf4....cb3edae4d25\u0026#34;) { .... poolId: null, shareId: \u0026#34;0xb5b01116f......71015afc6f\u0026#34;, //购买到的股份ID  .... }   查看本次股份购买的情况\n\u0026gt; stake.getShare(\u0026#34;0xb5b01116f......71015afc6f\u0026#34;) { addr: \u0026#34;5bEgN9YLq......4zeamkdD16C\u0026#34;, //资金账户收款码  fee: 0, //被抽成费率  id: \u0026#34;0xb5b01116f3e8......2a08b28171015afc6f\u0026#34;, //你的股份ID  lastPayTime: \u0026#34;0x147bf2\u0026#34;, //上次结算点块号  missed: 0, //丢失的票数  price: 2001844456911510800, //平均价格  profit: 20814755655292090000, //总收益  remaining: 71, //剩余股份数  returnNum: \u0026#34;0x19\u0026#34;, //已发放本金股份数 v1.0.0-rc6  returnProfit: \u0026#34;0xb6aa43a544af2\u0026#34;, //已发放奖励金额 v1.0.0-rc6  status: 0, //股份总状态：0 有效，1 过期，2 完成  total: 112, //总股份数  tx: \u0026#34;0x860867509de......1d9c5b0f6ee\u0026#34;, //购买该股份的交易hash  voteAddr: \u0026#34;2tuxyM5uL4ZDk......4xdTPCe5xNPokr\u0026#34; //投票账户的收款码 }   查看我的总股份情况\n\u0026gt; stake.myShare(\u0026#34;5bEgN9YLqCBN9......pti4zeamkdD16C\u0026#34;) [{ addr: \u0026#34;5bEgN9YLqCB......rpti4zeamkdD16C\u0026#34;, expired: 0, //股份过期数量  missed: 0, //投票miss数量  pools: null, remaining: 10, //剩下的股份数  shareIds: [ //我拥有的股份ID列表  \u0026#34;0x3f2ae......a0c656d9b7b7\u0026#34;, \u0026#34;0x58395b1......cfa4141d\u0026#34;, \u0026#34;0xb5b011......171015afc6f\u0026#34; ], total: 30, //我的总股份数  voteAddr: [\u0026#34;2tuxyM5uL4ZDkfp......Vtw4xdTPCe5xNPokr\u0026#34;] //我的投票ID }]   6. 查看账户余额\r#\r\r\u0026gt; web3.fromTa(zorro.getBalance(zorro.accounts[0]).tkn.ZORRO) //资金账户 339.980079865355683522 \u0026gt; zorro.getBalance(ZORRO.accounts[1]) //投票账户 {} 如何创建 Staking Node\r#\r\r由于个人网络不稳定，或者是无法持续的开启全节点，那么就可以委托给 Staking Node 代为投票。\n下面说明如何创建代为投票的 Staking Node\n前提\r#\r\r 拥有一个持续在线的全节点程序(ZORRO)。 拥有一个包含 20万 ZORRO 余额的链上账户。  实际需要 20万+1 ZORRO ，1 ZORRO 作为 Gas 费。   拥有良好的网络环境。  步骤\r#\r\r1. 步骤概要\r#\r\r 确认拥有用来质押的 20 万ZORRO代币。  Node 关闭的时候本金会退回   创建代投票账户。 开启自动代投票功能（解锁代投票账户）。 质押ZORRO币开通 Staking Node 查看当前节点委托情况情况。 确认收益。  2. 确认资产账户\r#\r\r\u0026gt; zorro.accounts[0] \u0026#34;5bEgN9YLqC......4zeamkdD16C\u0026#34; \u0026gt; web3.fromTa(zorro.getBalance(zorro.accounts[0]).tkn.ZORRO) 200000.980079865355683522 // \u0026gt; 20万 ZORRO 3. 创建代投票账户\r#\r\r\u0026gt; personal.newAccount(\u0026#34;1234\u0026#34;) \u0026#34;2tuxyM5uL4......w4xdTPCe5xNPokr\u0026#34; \u0026gt; zorro.accounts[1] \u0026#34;2tuxyM5uL4......Ce5xNPokr\u0026#34; 4. 开启自动代投票功能（解锁代投票账户）\r#\r\r投票账户需要永久解锁，以便于被抽中后可以快速的进行投票。\n\u0026gt; personal.unlockAccount(zorro.accounts[1],\u0026#34;1234\u0026#34;,0) 注意： StakingNode 需要确保全节点网络稳定，否则可能导致投票被 MISS，Miss的投票可能会导致StakingNode 本金锁定时间增加。\n5. 质押ZORRO币注册 Staking Node\r#\r\r客户端需要连接有10个以上的peer才能开启注册权益池的指令\n\u0026gt; admin.peers.length 15 开始注册StakingNode，注意在本例中accounts[0]拥有20万ZORRO币，是资金账户。\n\u0026gt; stake.registStakePool({ from:zorro.accounts[0], //资金账户  vote:zorro.accounts[1], //投票账户  value:web3.toTa(200000), //注册资金  fee:web3.toHex(2500) //抽成，最高7500代表抽成75%，最低2500代表抽成25% }) \u0026#34;0xecb3b5b235....8d35d7d1651\u0026#34; //注册生成的交易hash 可以通过查看交易收据查看本次注册的StakingNode的ID。\n\u0026gt; zorro.getTransactionReceipt(\u0026#34;0xecb3b5b....7d1651\u0026#34;) { ...... poolId: \u0026#34;0xb1e20b74......2b35888176d\u0026#34;, //StakingNode ID  shareId: null, ...... } **注意：**StakingNode 质押的本金需要锁定3个月之后才能解锁，但是必须在关闭权益池并且没有指向权益池的股份后才能回收。\n6. 查看当前节点委托情况情况以及收益\r#\r\r可以通过 poolState 方法查看StakingNode的状态。\n\u0026gt; stake.poolState(\u0026#34;0xb1e20b......88176d\u0026#34;) { choicedNum: \u0026#34;0x0\u0026#34;, //被选中的股份数量  closed: false, //Staking Node是否关闭  createAt: \u0026#34;0x11\u0026#34;, //Staking Node创建的时间  expireNum: \u0026#34;0x0\u0026#34;, //Staking Node过期委托股份数  fee: \u0026#34;0xfa0\u0026#34;, //Staking Node的抽成  id: \u0026#34;0xb1e20b7......88176d\u0026#34;, //Staking Node的ID  idPkr: \u0026#34;2E7uXmU9......GeQyGBzSvWE\u0026#34;, lastPayTime: \u0026#34;0x0\u0026#34;, //最后一次支付时间  missedNum: \u0026#34;0x0\u0026#34;, //错失的票数  own: \u0026#34;5bEgN9YLqC......4zeamkdD16C\u0026#34;, shareNum: \u0026#34;0x0\u0026#34;, //总股份数  tx: \u0026#34;0xecb3b5b......d1651\u0026#34;, voteAddress: \u0026#34;2tuxyM5uL4......w4xdTPCe5xNPokr\u0026#34;, wishVoteNum: \u0026#34;0x0\u0026#34;, profit: \u0026#34;0x100\u0026#34; returnProfit: \u0026#34;0x2d05ad6bd\u0026#34; //已发放奖励金额 v1.0.0-rc6 } 7. 节点统计接口 v1.0.0-rc6\r#\r\r有开发能力的用户可以通过统计接口迭代每一个块号的某个StakingNode和在其中Share的状态，得到更加细节的数据。\n\u0026gt; stake.getStakeInfo( \u0026#34;0xb1e20b......88176d\u0026#34;, //StakingNode Id  13400008, //起始块号  13400009 //结束块号(不包含在结果中) ) { pools: [{ //1300008 块时节点状态  blockNumber: 1300008, lastPayTime: 0, //结算块号，当这个值与blockNumber一致时，发放当前所有收益  ...... wishVoteNum: 0 }], shares: [{ //1300010 块时的股份状态  blockNumber: 1300010, lastPayTime: 0, //结算块号，当这个值与blockNumber一致时，发放当前所有收益和本金  ...... tx: \u0026#34;0xe622c3ff1b7863ed861252538f3bd52f78914af716a79121ccdf05f54d972a11\u0026#34; }] } 如何选中 Staking Node 为自己代投票\r#\r\r 普通用户只需要在购买股份的时候指定代投的Staking Node，即可不用部署全节点，享受方便的代投票服务。\n1.查询全网Staking Node列表\r#\r\r\u0026gt; stake.stakePools() [{ choicedNum: \u0026#34;0x0\u0026#34;, //被选中的股份数  closed: false, //是否关闭  createAt: \u0026#34;0x0\u0026#34;, expireNum: \u0026#34;0x0\u0026#34;, //过期股份数  fee: \u0026#34;0xfa0\u0026#34;, //抽成费用  id: \u0026#34;0xb1e20b7......2b35888176d\u0026#34;, //StakingNode ID  idPkr: \u0026#34;2E7uXm......yGBzSvWE\u0026#34;, lastPayTime: \u0026#34;0x0\u0026#34;, missedNum: \u0026#34;0x0\u0026#34;, //丢失票数  own: \u0026#34;4ujQrFsaYq......WZzxtnqgTsL\u0026#34;, shareNum: \u0026#34;0x0\u0026#34;, //总股份数  tx: \u0026#34;0xecb3b5b......35d7d1651\u0026#34;, voteAddress: \u0026#34;21F6gyEUw......zMZ5VtGL2\u0026#34;, wishVoteNum: \u0026#34;0x0\u0026#34; }, { choicedNum: \u0026#34;0xac\u0026#34;, closed: false, createAt: \u0026#34;0x0\u0026#34;, expireNum: \u0026#34;0x30d\u0026#34;, fee: \u0026#34;0x123b\u0026#34;, id: \u0026#34;0xc48e455......2af708a\u0026#34;, idPkr: \u0026#34;2WCHu3......jbFrXWE\u0026#34;, lastPayTime: \u0026#34;0x12b404\u0026#34;, missedNum: \u0026#34;0x60\u0026#34;, own: \u0026#34;2WCHu3bM......jbFrXWE\u0026#34;, shareNum: \u0026#34;0x4fe\u0026#34;, tx: \u0026#34;0xb9a0a......dc0212\u0026#34;, voteAddress: \u0026#34;JyRPyD8n......bucfZbRH\u0026#34;, wishVoteNum: \u0026#34;0x0\u0026#34; }] 2. 在购买股份的时候选择代投票Staking Node\r#\r\r\u0026gt; stake.buyShare({ from:zorro.accounts[0], //你的资金账户  vote:zorro.accounts[1], //你的投票账户  pool:\u0026#34;0xc48e45......af708a\u0026#34;, //选择 StakingNode ID  value:web3.toTa(2000) }) \u0026#34;0xb524ec5......b8d511b0b\u0026#34; \u0026gt; zorro.getTransactionReceipt(\u0026#34;0xb524e......8d511b0b\u0026#34;) { ...... shareId: \u0026#34;0x9e415fa4......94e4eef\u0026#34;, //购买的股份ID  ...... }  需要注意的是，在Staking Node工作正常的情况下，不要在全节点账户中解锁你自己的投票账户，因为这样可能会导致收益减少。 当Staking Node恶意罢工的情况下，才解锁自己的投票账户，进行SOLO投票减少损失。  3. 确认票的Staking Node的情况\r#\r\r\u0026gt; stake.getShare(\u0026#34;0x9e415f......94e4eef\u0026#34;) { addr: \u0026#34;4ujQrFsaY......zxtnqgTsL\u0026#34;, id: \u0026#34;0x9e415f......994e4eef\u0026#34;, missed: 0, num: 723, pool: \u0026#34;0xc48e4557......ec62af708a\u0026#34;, //本股份选择的StakingNode ID  price: 2739073884442371600, returnAmount: 23602264528913793000, //收益  status: 0, total: 730, tx: \u0026#34;0xb524ec5......b8d511b0b\u0026#34;, voteAddr: \u0026#34;4ujQrFsaYq......qWZzxtnqgTsL\u0026#34; } 本金退回的情况\r#\r\r  Staking的设计不会没收或者销毁任何用户的本金。 发送下面几种情况的时候，股份的本金会退回  完成投票过程的股份，在发放奖励的同时退回本金。 股份超过1个月没有被任何矿工选中，会退回本金。 被选中但没有回应的股份，在第3个月的时候被退回。   同时发生下面几种情况的时候，StakingNode本金会被退回  StakingNode被所有者关闭 StakingNode注册完成满一个月 票池中已经没有委托该StakingNode的股份    "});index.add({'id':9,'href':'/docs/','title':"Docs",'content':""});})();